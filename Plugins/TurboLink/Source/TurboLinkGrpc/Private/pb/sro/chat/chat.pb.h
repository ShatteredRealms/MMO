#if defined(_MSC_VER)
  #pragma warning (disable:4946) // reinterpret_cast used between related classes: 'class1' and 'class2'
  #pragma warning (disable:4800) // 'type' : forcing value to bool 'true' or 'false' (performance warning)
  #pragma warning (disable:4582) // 'type': constructor is not implicitly called
#endif
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sro/chat/chat.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_sro_2fchat_2fchat_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_sro_2fchat_2fchat_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "google/api/annotations.pb.h"
#include "google/protobuf/empty.pb.h"
#include "sro/globals.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_sro_2fchat_2fchat_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_sro_2fchat_2fchat_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_sro_2fchat_2fchat_2eproto;
namespace sro {
namespace chat {
class BanRequest;
struct BanRequestDefaultTypeInternal;
extern BanRequestDefaultTypeInternal _BanRequest_default_instance_;
class ChatChannel;
struct ChatChannelDefaultTypeInternal;
extern ChatChannelDefaultTypeInternal _ChatChannel_default_instance_;
class ChatChannels;
struct ChatChannelsDefaultTypeInternal;
extern ChatChannelsDefaultTypeInternal _ChatChannels_default_instance_;
class ChatLog;
struct ChatLogDefaultTypeInternal;
extern ChatLogDefaultTypeInternal _ChatLog_default_instance_;
class ChatLogRequest;
struct ChatLogRequestDefaultTypeInternal;
extern ChatLogRequestDefaultTypeInternal _ChatLogRequest_default_instance_;
class ChatLogs;
struct ChatLogsDefaultTypeInternal;
extern ChatLogsDefaultTypeInternal _ChatLogs_default_instance_;
class ChatMessage;
struct ChatMessageDefaultTypeInternal;
extern ChatMessageDefaultTypeInternal _ChatMessage_default_instance_;
class ConnectChatChannelRequest;
struct ConnectChatChannelRequestDefaultTypeInternal;
extern ConnectChatChannelRequestDefaultTypeInternal _ConnectChatChannelRequest_default_instance_;
class CreateChatChannelMessage;
struct CreateChatChannelMessageDefaultTypeInternal;
extern CreateChatChannelMessageDefaultTypeInternal _CreateChatChannelMessage_default_instance_;
class RequestSetCharacterSetChatChannelAuth;
struct RequestSetCharacterSetChatChannelAuthDefaultTypeInternal;
extern RequestSetCharacterSetChatChannelAuthDefaultTypeInternal _RequestSetCharacterSetChatChannelAuth_default_instance_;
class RequestUpdateCharacterSetChatChannelAuth;
struct RequestUpdateCharacterSetChatChannelAuthDefaultTypeInternal;
extern RequestUpdateCharacterSetChatChannelAuthDefaultTypeInternal _RequestUpdateCharacterSetChatChannelAuth_default_instance_;
class SendChatChannelMessageRequest;
struct SendChatChannelMessageRequestDefaultTypeInternal;
extern SendChatChannelMessageRequestDefaultTypeInternal _SendChatChannelMessageRequest_default_instance_;
class SendDirectMessageRequest;
struct SendDirectMessageRequestDefaultTypeInternal;
extern SendDirectMessageRequestDefaultTypeInternal _SendDirectMessageRequest_default_instance_;
class UpdateChatChannelRequest;
struct UpdateChatChannelRequestDefaultTypeInternal;
extern UpdateChatChannelRequestDefaultTypeInternal _UpdateChatChannelRequest_default_instance_;
}  // namespace chat
}  // namespace sro
PROTOBUF_NAMESPACE_OPEN
template <>
::sro::chat::BanRequest* Arena::CreateMaybeMessage<::sro::chat::BanRequest>(Arena*);
template <>
::sro::chat::ChatChannel* Arena::CreateMaybeMessage<::sro::chat::ChatChannel>(Arena*);
template <>
::sro::chat::ChatChannels* Arena::CreateMaybeMessage<::sro::chat::ChatChannels>(Arena*);
template <>
::sro::chat::ChatLog* Arena::CreateMaybeMessage<::sro::chat::ChatLog>(Arena*);
template <>
::sro::chat::ChatLogRequest* Arena::CreateMaybeMessage<::sro::chat::ChatLogRequest>(Arena*);
template <>
::sro::chat::ChatLogs* Arena::CreateMaybeMessage<::sro::chat::ChatLogs>(Arena*);
template <>
::sro::chat::ChatMessage* Arena::CreateMaybeMessage<::sro::chat::ChatMessage>(Arena*);
template <>
::sro::chat::ConnectChatChannelRequest* Arena::CreateMaybeMessage<::sro::chat::ConnectChatChannelRequest>(Arena*);
template <>
::sro::chat::CreateChatChannelMessage* Arena::CreateMaybeMessage<::sro::chat::CreateChatChannelMessage>(Arena*);
template <>
::sro::chat::RequestSetCharacterSetChatChannelAuth* Arena::CreateMaybeMessage<::sro::chat::RequestSetCharacterSetChatChannelAuth>(Arena*);
template <>
::sro::chat::RequestUpdateCharacterSetChatChannelAuth* Arena::CreateMaybeMessage<::sro::chat::RequestUpdateCharacterSetChatChannelAuth>(Arena*);
template <>
::sro::chat::SendChatChannelMessageRequest* Arena::CreateMaybeMessage<::sro::chat::SendChatChannelMessageRequest>(Arena*);
template <>
::sro::chat::SendDirectMessageRequest* Arena::CreateMaybeMessage<::sro::chat::SendDirectMessageRequest>(Arena*);
template <>
::sro::chat::UpdateChatChannelRequest* Arena::CreateMaybeMessage<::sro::chat::UpdateChatChannelRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace sro {
namespace chat {

// ===================================================================


// -------------------------------------------------------------------

class ChatLogRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sro.chat.ChatLogRequest) */ {
 public:
  inline ChatLogRequest() : ChatLogRequest(nullptr) {}
  ~ChatLogRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChatLogRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChatLogRequest(const ChatLogRequest& from);
  ChatLogRequest(ChatLogRequest&& from) noexcept
    : ChatLogRequest() {
    *this = ::std::move(from);
  }

  inline ChatLogRequest& operator=(const ChatLogRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatLogRequest& operator=(ChatLogRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatLogRequest& default_instance() {
    return *internal_default_instance();
  }
  enum OptionalSenderIdCase {
    kSenderId = 2,
    OPTIONAL_SENDER_ID_NOT_SET = 0,
  };

  enum OptionalBeforeCase {
    kBefore = 3,
    OPTIONAL_BEFORE_NOT_SET = 0,
  };

  enum OptionalAfterCase {
    kAfter = 4,
    OPTIONAL_AFTER_NOT_SET = 0,
  };

  enum OptionalLimitCase {
    kLimit = 5,
    OPTIONAL_LIMIT_NOT_SET = 0,
  };

  enum OptionalOffsetCase {
    kOffset = 6,
    OPTIONAL_OFFSET_NOT_SET = 0,
  };

  static inline const ChatLogRequest* internal_default_instance() {
    return reinterpret_cast<const ChatLogRequest*>(
               &_ChatLogRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ChatLogRequest& a, ChatLogRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatLogRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatLogRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatLogRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatLogRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChatLogRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChatLogRequest& from) {
    ChatLogRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatLogRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sro.chat.ChatLogRequest";
  }
  protected:
  explicit ChatLogRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelIdFieldNumber = 1,
    kSenderIdFieldNumber = 2,
    kBeforeFieldNumber = 3,
    kAfterFieldNumber = 4,
    kLimitFieldNumber = 5,
    kOffsetFieldNumber = 6,
  };
  // string channel_id = 1;
  void clear_channel_id() ;
  const std::string& channel_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_channel_id(Arg_&& arg, Args_... args);
  std::string* mutable_channel_id();
  PROTOBUF_NODISCARD std::string* release_channel_id();
  void set_allocated_channel_id(std::string* ptr);

  private:
  const std::string& _internal_channel_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_channel_id(
      const std::string& value);
  std::string* _internal_mutable_channel_id();

  public:
  // string sender_id = 2;
  bool has_sender_id() const;
  void clear_sender_id() ;
  const std::string& sender_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender_id(Arg_&& arg, Args_... args);
  std::string* mutable_sender_id();
  PROTOBUF_NODISCARD std::string* release_sender_id();
  void set_allocated_sender_id(std::string* ptr);

  private:
  const std::string& _internal_sender_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender_id(
      const std::string& value);
  std::string* _internal_mutable_sender_id();

  public:
  // int64 before = 3;
  bool has_before() const;
  void clear_before() ;
  ::int64_t before() const;
  void set_before(::int64_t value);

  private:
  ::int64_t _internal_before() const;
  void _internal_set_before(::int64_t value);

  public:
  // int64 after = 4;
  bool has_after() const;
  void clear_after() ;
  ::int64_t after() const;
  void set_after(::int64_t value);

  private:
  ::int64_t _internal_after() const;
  void _internal_set_after(::int64_t value);

  public:
  // uint64 limit = 5;
  bool has_limit() const;
  void clear_limit() ;
  ::uint64_t limit() const;
  void set_limit(::uint64_t value);

  private:
  ::uint64_t _internal_limit() const;
  void _internal_set_limit(::uint64_t value);

  public:
  // uint64 offset = 6;
  bool has_offset() const;
  void clear_offset() ;
  ::uint64_t offset() const;
  void set_offset(::uint64_t value);

  private:
  ::uint64_t _internal_offset() const;
  void _internal_set_offset(::uint64_t value);

  public:
  void clear_optional_sender_id();
  OptionalSenderIdCase optional_sender_id_case() const;
  void clear_optional_before();
  OptionalBeforeCase optional_before_case() const;
  void clear_optional_after();
  OptionalAfterCase optional_after_case() const;
  void clear_optional_limit();
  OptionalLimitCase optional_limit_case() const;
  void clear_optional_offset();
  OptionalOffsetCase optional_offset_case() const;
  // @@protoc_insertion_point(class_scope:sro.chat.ChatLogRequest)
 private:
  class _Internal;
  void set_has_sender_id();
  void set_has_before();
  void set_has_after();
  void set_has_limit();
  void set_has_offset();

  inline bool has_optional_sender_id() const;
  inline void clear_has_optional_sender_id();

  inline bool has_optional_before() const;
  inline void clear_has_optional_before();

  inline bool has_optional_after() const;
  inline void clear_has_optional_after();

  inline bool has_optional_limit() const;
  inline void clear_has_optional_limit();

  inline bool has_optional_offset() const;
  inline void clear_has_optional_offset();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr channel_id_;
    union OptionalSenderIdUnion {
      constexpr OptionalSenderIdUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_id_;
    } optional_sender_id_;
    union OptionalBeforeUnion {
      constexpr OptionalBeforeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::int64_t before_;
    } optional_before_;
    union OptionalAfterUnion {
      constexpr OptionalAfterUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::int64_t after_;
    } optional_after_;
    union OptionalLimitUnion {
      constexpr OptionalLimitUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::uint64_t limit_;
    } optional_limit_;
    union OptionalOffsetUnion {
      constexpr OptionalOffsetUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::uint64_t offset_;
    } optional_offset_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[5];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sro_2fchat_2fchat_2eproto;
};// -------------------------------------------------------------------

class ChatLog final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sro.chat.ChatLog) */ {
 public:
  inline ChatLog() : ChatLog(nullptr) {}
  ~ChatLog() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChatLog(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChatLog(const ChatLog& from);
  ChatLog(ChatLog&& from) noexcept
    : ChatLog() {
    *this = ::std::move(from);
  }

  inline ChatLog& operator=(const ChatLog& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatLog& operator=(ChatLog&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatLog& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatLog* internal_default_instance() {
    return reinterpret_cast<const ChatLog*>(
               &_ChatLog_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ChatLog& a, ChatLog& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatLog* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatLog* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatLog* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatLog>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChatLog& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChatLog& from) {
    ChatLog::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatLog* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sro.chat.ChatLog";
  }
  protected:
  explicit ChatLog(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelIdFieldNumber = 2,
    kSenderIdFieldNumber = 3,
    kContentFieldNumber = 4,
    kSentAtFieldNumber = 1,
  };
  // string channel_id = 2;
  void clear_channel_id() ;
  const std::string& channel_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_channel_id(Arg_&& arg, Args_... args);
  std::string* mutable_channel_id();
  PROTOBUF_NODISCARD std::string* release_channel_id();
  void set_allocated_channel_id(std::string* ptr);

  private:
  const std::string& _internal_channel_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_channel_id(
      const std::string& value);
  std::string* _internal_mutable_channel_id();

  public:
  // string sender_id = 3;
  void clear_sender_id() ;
  const std::string& sender_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender_id(Arg_&& arg, Args_... args);
  std::string* mutable_sender_id();
  PROTOBUF_NODISCARD std::string* release_sender_id();
  void set_allocated_sender_id(std::string* ptr);

  private:
  const std::string& _internal_sender_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender_id(
      const std::string& value);
  std::string* _internal_mutable_sender_id();

  public:
  // string content = 4;
  void clear_content() ;
  const std::string& content() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_content(Arg_&& arg, Args_... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* ptr);

  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(
      const std::string& value);
  std::string* _internal_mutable_content();

  public:
  // uint64 sent_at = 1;
  void clear_sent_at() ;
  ::uint64_t sent_at() const;
  void set_sent_at(::uint64_t value);

  private:
  ::uint64_t _internal_sent_at() const;
  void _internal_set_sent_at(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:sro.chat.ChatLog)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr channel_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    ::uint64_t sent_at_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sro_2fchat_2fchat_2eproto;
};// -------------------------------------------------------------------

class ChatLogs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sro.chat.ChatLogs) */ {
 public:
  inline ChatLogs() : ChatLogs(nullptr) {}
  ~ChatLogs() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChatLogs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChatLogs(const ChatLogs& from);
  ChatLogs(ChatLogs&& from) noexcept
    : ChatLogs() {
    *this = ::std::move(from);
  }

  inline ChatLogs& operator=(const ChatLogs& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatLogs& operator=(ChatLogs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatLogs& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatLogs* internal_default_instance() {
    return reinterpret_cast<const ChatLogs*>(
               &_ChatLogs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ChatLogs& a, ChatLogs& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatLogs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatLogs* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatLogs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatLogs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChatLogs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChatLogs& from) {
    ChatLogs::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatLogs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sro.chat.ChatLogs";
  }
  protected:
  explicit ChatLogs(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogsFieldNumber = 2,
    kTotalFieldNumber = 1,
  };
  // repeated .sro.chat.ChatLog logs = 2;
  int logs_size() const;
  private:
  int _internal_logs_size() const;

  public:
  void clear_logs() ;
  ::sro::chat::ChatLog* mutable_logs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::chat::ChatLog >*
      mutable_logs();
  private:
  const ::sro::chat::ChatLog& _internal_logs(int index) const;
  ::sro::chat::ChatLog* _internal_add_logs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sro::chat::ChatLog>& _internal_logs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sro::chat::ChatLog>* _internal_mutable_logs();
  public:
  const ::sro::chat::ChatLog& logs(int index) const;
  ::sro::chat::ChatLog* add_logs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::chat::ChatLog >&
      logs() const;
  // uint64 total = 1;
  void clear_total() ;
  ::uint64_t total() const;
  void set_total(::uint64_t value);

  private:
  ::uint64_t _internal_total() const;
  void _internal_set_total(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:sro.chat.ChatLogs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::chat::ChatLog > logs_;
    ::uint64_t total_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sro_2fchat_2fchat_2eproto;
};// -------------------------------------------------------------------

class BanRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sro.chat.BanRequest) */ {
 public:
  inline BanRequest() : BanRequest(nullptr) {}
  ~BanRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BanRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BanRequest(const BanRequest& from);
  BanRequest(BanRequest&& from) noexcept
    : BanRequest() {
    *this = ::std::move(from);
  }

  inline BanRequest& operator=(const BanRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BanRequest& operator=(BanRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BanRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BanRequest* internal_default_instance() {
    return reinterpret_cast<const BanRequest*>(
               &_BanRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(BanRequest& a, BanRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BanRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BanRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BanRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BanRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BanRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BanRequest& from) {
    BanRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BanRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sro.chat.BanRequest";
  }
  protected:
  explicit BanRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCharacterIdFieldNumber = 1,
    kChannelIdFieldNumber = 2,
    kDurationFieldNumber = 3,
  };
  // string character_id = 1;
  void clear_character_id() ;
  const std::string& character_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_character_id(Arg_&& arg, Args_... args);
  std::string* mutable_character_id();
  PROTOBUF_NODISCARD std::string* release_character_id();
  void set_allocated_character_id(std::string* ptr);

  private:
  const std::string& _internal_character_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_character_id(
      const std::string& value);
  std::string* _internal_mutable_character_id();

  public:
  // string channel_id = 2;
  void clear_channel_id() ;
  const std::string& channel_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_channel_id(Arg_&& arg, Args_... args);
  std::string* mutable_channel_id();
  PROTOBUF_NODISCARD std::string* release_channel_id();
  void set_allocated_channel_id(std::string* ptr);

  private:
  const std::string& _internal_channel_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_channel_id(
      const std::string& value);
  std::string* _internal_mutable_channel_id();

  public:
  // int64 duration = 3;
  void clear_duration() ;
  ::int64_t duration() const;
  void set_duration(::int64_t value);

  private:
  ::int64_t _internal_duration() const;
  void _internal_set_duration(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:sro.chat.BanRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr character_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr channel_id_;
    ::int64_t duration_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sro_2fchat_2fchat_2eproto;
};// -------------------------------------------------------------------

class ConnectChatChannelRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sro.chat.ConnectChatChannelRequest) */ {
 public:
  inline ConnectChatChannelRequest() : ConnectChatChannelRequest(nullptr) {}
  ~ConnectChatChannelRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ConnectChatChannelRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConnectChatChannelRequest(const ConnectChatChannelRequest& from);
  ConnectChatChannelRequest(ConnectChatChannelRequest&& from) noexcept
    : ConnectChatChannelRequest() {
    *this = ::std::move(from);
  }

  inline ConnectChatChannelRequest& operator=(const ConnectChatChannelRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectChatChannelRequest& operator=(ConnectChatChannelRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnectChatChannelRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectChatChannelRequest* internal_default_instance() {
    return reinterpret_cast<const ConnectChatChannelRequest*>(
               &_ConnectChatChannelRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ConnectChatChannelRequest& a, ConnectChatChannelRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectChatChannelRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectChatChannelRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectChatChannelRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectChatChannelRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConnectChatChannelRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConnectChatChannelRequest& from) {
    ConnectChatChannelRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectChatChannelRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sro.chat.ConnectChatChannelRequest";
  }
  protected:
  explicit ConnectChatChannelRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelIdFieldNumber = 1,
    kCharacterIdFieldNumber = 2,
  };
  // string channel_id = 1;
  void clear_channel_id() ;
  const std::string& channel_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_channel_id(Arg_&& arg, Args_... args);
  std::string* mutable_channel_id();
  PROTOBUF_NODISCARD std::string* release_channel_id();
  void set_allocated_channel_id(std::string* ptr);

  private:
  const std::string& _internal_channel_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_channel_id(
      const std::string& value);
  std::string* _internal_mutable_channel_id();

  public:
  // string character_id = 2;
  void clear_character_id() ;
  const std::string& character_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_character_id(Arg_&& arg, Args_... args);
  std::string* mutable_character_id();
  PROTOBUF_NODISCARD std::string* release_character_id();
  void set_allocated_character_id(std::string* ptr);

  private:
  const std::string& _internal_character_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_character_id(
      const std::string& value);
  std::string* _internal_mutable_character_id();

  public:
  // @@protoc_insertion_point(class_scope:sro.chat.ConnectChatChannelRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr channel_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr character_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sro_2fchat_2fchat_2eproto;
};// -------------------------------------------------------------------

class RequestSetCharacterSetChatChannelAuth final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sro.chat.RequestSetCharacterSetChatChannelAuth) */ {
 public:
  inline RequestSetCharacterSetChatChannelAuth() : RequestSetCharacterSetChatChannelAuth(nullptr) {}
  ~RequestSetCharacterSetChatChannelAuth() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RequestSetCharacterSetChatChannelAuth(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestSetCharacterSetChatChannelAuth(const RequestSetCharacterSetChatChannelAuth& from);
  RequestSetCharacterSetChatChannelAuth(RequestSetCharacterSetChatChannelAuth&& from) noexcept
    : RequestSetCharacterSetChatChannelAuth() {
    *this = ::std::move(from);
  }

  inline RequestSetCharacterSetChatChannelAuth& operator=(const RequestSetCharacterSetChatChannelAuth& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestSetCharacterSetChatChannelAuth& operator=(RequestSetCharacterSetChatChannelAuth&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestSetCharacterSetChatChannelAuth& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestSetCharacterSetChatChannelAuth* internal_default_instance() {
    return reinterpret_cast<const RequestSetCharacterSetChatChannelAuth*>(
               &_RequestSetCharacterSetChatChannelAuth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RequestSetCharacterSetChatChannelAuth& a, RequestSetCharacterSetChatChannelAuth& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestSetCharacterSetChatChannelAuth* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestSetCharacterSetChatChannelAuth* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestSetCharacterSetChatChannelAuth* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestSetCharacterSetChatChannelAuth>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestSetCharacterSetChatChannelAuth& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestSetCharacterSetChatChannelAuth& from) {
    RequestSetCharacterSetChatChannelAuth::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestSetCharacterSetChatChannelAuth* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sro.chat.RequestSetCharacterSetChatChannelAuth";
  }
  protected:
  explicit RequestSetCharacterSetChatChannelAuth(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdsFieldNumber = 2,
    kCharacterIdFieldNumber = 1,
  };
  // repeated string ids = 2;
  int ids_size() const;
  private:
  int _internal_ids_size() const;

  public:
  void clear_ids() ;
  const std::string& ids(int index) const;
  std::string* mutable_ids(int index);
  void set_ids(int index, const std::string& value);
  void set_ids(int index, std::string&& value);
  void set_ids(int index, const char* value);
  void set_ids(int index, const char* value, std::size_t size);
  void set_ids(int index, absl::string_view value);
  std::string* add_ids();
  void add_ids(const std::string& value);
  void add_ids(std::string&& value);
  void add_ids(const char* value);
  void add_ids(const char* value, std::size_t size);
  void add_ids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_ids();

  private:
  const std::string& _internal_ids(int index) const;
  std::string* _internal_add_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_ids();

  public:
  // string character_id = 1;
  void clear_character_id() ;
  const std::string& character_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_character_id(Arg_&& arg, Args_... args);
  std::string* mutable_character_id();
  PROTOBUF_NODISCARD std::string* release_character_id();
  void set_allocated_character_id(std::string* ptr);

  private:
  const std::string& _internal_character_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_character_id(
      const std::string& value);
  std::string* _internal_mutable_character_id();

  public:
  // @@protoc_insertion_point(class_scope:sro.chat.RequestSetCharacterSetChatChannelAuth)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr character_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sro_2fchat_2fchat_2eproto;
};// -------------------------------------------------------------------

class RequestUpdateCharacterSetChatChannelAuth final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sro.chat.RequestUpdateCharacterSetChatChannelAuth) */ {
 public:
  inline RequestUpdateCharacterSetChatChannelAuth() : RequestUpdateCharacterSetChatChannelAuth(nullptr) {}
  ~RequestUpdateCharacterSetChatChannelAuth() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RequestUpdateCharacterSetChatChannelAuth(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestUpdateCharacterSetChatChannelAuth(const RequestUpdateCharacterSetChatChannelAuth& from);
  RequestUpdateCharacterSetChatChannelAuth(RequestUpdateCharacterSetChatChannelAuth&& from) noexcept
    : RequestUpdateCharacterSetChatChannelAuth() {
    *this = ::std::move(from);
  }

  inline RequestUpdateCharacterSetChatChannelAuth& operator=(const RequestUpdateCharacterSetChatChannelAuth& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestUpdateCharacterSetChatChannelAuth& operator=(RequestUpdateCharacterSetChatChannelAuth&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestUpdateCharacterSetChatChannelAuth& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestUpdateCharacterSetChatChannelAuth* internal_default_instance() {
    return reinterpret_cast<const RequestUpdateCharacterSetChatChannelAuth*>(
               &_RequestUpdateCharacterSetChatChannelAuth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RequestUpdateCharacterSetChatChannelAuth& a, RequestUpdateCharacterSetChatChannelAuth& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestUpdateCharacterSetChatChannelAuth* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestUpdateCharacterSetChatChannelAuth* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestUpdateCharacterSetChatChannelAuth* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestUpdateCharacterSetChatChannelAuth>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestUpdateCharacterSetChatChannelAuth& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestUpdateCharacterSetChatChannelAuth& from) {
    RequestUpdateCharacterSetChatChannelAuth::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestUpdateCharacterSetChatChannelAuth* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sro.chat.RequestUpdateCharacterSetChatChannelAuth";
  }
  protected:
  explicit RequestUpdateCharacterSetChatChannelAuth(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdsFieldNumber = 3,
    kCharacterIdFieldNumber = 1,
    kAddFieldNumber = 2,
  };
  // repeated string ids = 3;
  int ids_size() const;
  private:
  int _internal_ids_size() const;

  public:
  void clear_ids() ;
  const std::string& ids(int index) const;
  std::string* mutable_ids(int index);
  void set_ids(int index, const std::string& value);
  void set_ids(int index, std::string&& value);
  void set_ids(int index, const char* value);
  void set_ids(int index, const char* value, std::size_t size);
  void set_ids(int index, absl::string_view value);
  std::string* add_ids();
  void add_ids(const std::string& value);
  void add_ids(std::string&& value);
  void add_ids(const char* value);
  void add_ids(const char* value, std::size_t size);
  void add_ids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_ids();

  private:
  const std::string& _internal_ids(int index) const;
  std::string* _internal_add_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_ids();

  public:
  // string character_id = 1;
  void clear_character_id() ;
  const std::string& character_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_character_id(Arg_&& arg, Args_... args);
  std::string* mutable_character_id();
  PROTOBUF_NODISCARD std::string* release_character_id();
  void set_allocated_character_id(std::string* ptr);

  private:
  const std::string& _internal_character_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_character_id(
      const std::string& value);
  std::string* _internal_mutable_character_id();

  public:
  // bool add = 2;
  void clear_add() ;
  bool add() const;
  void set_add(bool value);

  private:
  bool _internal_add() const;
  void _internal_set_add(bool value);

  public:
  // @@protoc_insertion_point(class_scope:sro.chat.RequestUpdateCharacterSetChatChannelAuth)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr character_id_;
    bool add_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sro_2fchat_2fchat_2eproto;
};// -------------------------------------------------------------------

class ChatChannel final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sro.chat.ChatChannel) */ {
 public:
  inline ChatChannel() : ChatChannel(nullptr) {}
  ~ChatChannel() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChatChannel(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChatChannel(const ChatChannel& from);
  ChatChannel(ChatChannel&& from) noexcept
    : ChatChannel() {
    *this = ::std::move(from);
  }

  inline ChatChannel& operator=(const ChatChannel& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatChannel& operator=(ChatChannel&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatChannel& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatChannel* internal_default_instance() {
    return reinterpret_cast<const ChatChannel*>(
               &_ChatChannel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ChatChannel& a, ChatChannel& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatChannel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatChannel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatChannel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatChannel>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChatChannel& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChatChannel& from) {
    ChatChannel::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatChannel* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sro.chat.ChatChannel";
  }
  protected:
  explicit ChatChannel(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kDimensionIdFieldNumber = 3,
    kPublicFieldNumber = 4,
  };
  // string id = 1;
  void clear_id() ;
  const std::string& id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string dimension_id = 3;
  void clear_dimension_id() ;
  const std::string& dimension_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dimension_id(Arg_&& arg, Args_... args);
  std::string* mutable_dimension_id();
  PROTOBUF_NODISCARD std::string* release_dimension_id();
  void set_allocated_dimension_id(std::string* ptr);

  private:
  const std::string& _internal_dimension_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dimension_id(
      const std::string& value);
  std::string* _internal_mutable_dimension_id();

  public:
  // bool public = 4;
  void clear_public_() ;
  bool public_() const;
  void set_public_(bool value);

  private:
  bool _internal_public_() const;
  void _internal_set_public_(bool value);

  public:
  // @@protoc_insertion_point(class_scope:sro.chat.ChatChannel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dimension_id_;
    bool public__;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sro_2fchat_2fchat_2eproto;
};// -------------------------------------------------------------------

class ChatChannels final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sro.chat.ChatChannels) */ {
 public:
  inline ChatChannels() : ChatChannels(nullptr) {}
  ~ChatChannels() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChatChannels(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChatChannels(const ChatChannels& from);
  ChatChannels(ChatChannels&& from) noexcept
    : ChatChannels() {
    *this = ::std::move(from);
  }

  inline ChatChannels& operator=(const ChatChannels& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatChannels& operator=(ChatChannels&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatChannels& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatChannels* internal_default_instance() {
    return reinterpret_cast<const ChatChannels*>(
               &_ChatChannels_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ChatChannels& a, ChatChannels& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatChannels* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatChannels* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatChannels* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatChannels>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChatChannels& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChatChannels& from) {
    ChatChannels::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatChannels* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sro.chat.ChatChannels";
  }
  protected:
  explicit ChatChannels(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelsFieldNumber = 1,
  };
  // repeated .sro.chat.ChatChannel channels = 1;
  int channels_size() const;
  private:
  int _internal_channels_size() const;

  public:
  void clear_channels() ;
  ::sro::chat::ChatChannel* mutable_channels(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::chat::ChatChannel >*
      mutable_channels();
  private:
  const ::sro::chat::ChatChannel& _internal_channels(int index) const;
  ::sro::chat::ChatChannel* _internal_add_channels();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sro::chat::ChatChannel>& _internal_channels() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sro::chat::ChatChannel>* _internal_mutable_channels();
  public:
  const ::sro::chat::ChatChannel& channels(int index) const;
  ::sro::chat::ChatChannel* add_channels();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::chat::ChatChannel >&
      channels() const;
  // @@protoc_insertion_point(class_scope:sro.chat.ChatChannels)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::chat::ChatChannel > channels_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sro_2fchat_2fchat_2eproto;
};// -------------------------------------------------------------------

class CreateChatChannelMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sro.chat.CreateChatChannelMessage) */ {
 public:
  inline CreateChatChannelMessage() : CreateChatChannelMessage(nullptr) {}
  ~CreateChatChannelMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CreateChatChannelMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateChatChannelMessage(const CreateChatChannelMessage& from);
  CreateChatChannelMessage(CreateChatChannelMessage&& from) noexcept
    : CreateChatChannelMessage() {
    *this = ::std::move(from);
  }

  inline CreateChatChannelMessage& operator=(const CreateChatChannelMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateChatChannelMessage& operator=(CreateChatChannelMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateChatChannelMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateChatChannelMessage* internal_default_instance() {
    return reinterpret_cast<const CreateChatChannelMessage*>(
               &_CreateChatChannelMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CreateChatChannelMessage& a, CreateChatChannelMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateChatChannelMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateChatChannelMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateChatChannelMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateChatChannelMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateChatChannelMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateChatChannelMessage& from) {
    CreateChatChannelMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateChatChannelMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sro.chat.CreateChatChannelMessage";
  }
  protected:
  explicit CreateChatChannelMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDimensionIdFieldNumber = 2,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string dimension_id = 2;
  void clear_dimension_id() ;
  const std::string& dimension_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dimension_id(Arg_&& arg, Args_... args);
  std::string* mutable_dimension_id();
  PROTOBUF_NODISCARD std::string* release_dimension_id();
  void set_allocated_dimension_id(std::string* ptr);

  private:
  const std::string& _internal_dimension_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dimension_id(
      const std::string& value);
  std::string* _internal_mutable_dimension_id();

  public:
  // @@protoc_insertion_point(class_scope:sro.chat.CreateChatChannelMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dimension_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sro_2fchat_2fchat_2eproto;
};// -------------------------------------------------------------------

class ChatMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sro.chat.ChatMessage) */ {
 public:
  inline ChatMessage() : ChatMessage(nullptr) {}
  ~ChatMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChatMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChatMessage(const ChatMessage& from);
  ChatMessage(ChatMessage&& from) noexcept
    : ChatMessage() {
    *this = ::std::move(from);
  }

  inline ChatMessage& operator=(const ChatMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatMessage& operator=(ChatMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatMessage* internal_default_instance() {
    return reinterpret_cast<const ChatMessage*>(
               &_ChatMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ChatMessage& a, ChatMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChatMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChatMessage& from) {
    ChatMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sro.chat.ChatMessage";
  }
  protected:
  explicit ChatMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderCharacterIdFieldNumber = 1,
    kContentFieldNumber = 2,
    kSentTimeMsFieldNumber = 3,
  };
  // string sender_character_id = 1;
  void clear_sender_character_id() ;
  const std::string& sender_character_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender_character_id(Arg_&& arg, Args_... args);
  std::string* mutable_sender_character_id();
  PROTOBUF_NODISCARD std::string* release_sender_character_id();
  void set_allocated_sender_character_id(std::string* ptr);

  private:
  const std::string& _internal_sender_character_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender_character_id(
      const std::string& value);
  std::string* _internal_mutable_sender_character_id();

  public:
  // string content = 2;
  void clear_content() ;
  const std::string& content() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_content(Arg_&& arg, Args_... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* ptr);

  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(
      const std::string& value);
  std::string* _internal_mutable_content();

  public:
  // int64 sent_time_ms = 3;
  void clear_sent_time_ms() ;
  ::int64_t sent_time_ms() const;
  void set_sent_time_ms(::int64_t value);

  private:
  ::int64_t _internal_sent_time_ms() const;
  void _internal_set_sent_time_ms(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:sro.chat.ChatMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_character_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    ::int64_t sent_time_ms_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sro_2fchat_2fchat_2eproto;
};// -------------------------------------------------------------------

class SendChatChannelMessageRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sro.chat.SendChatChannelMessageRequest) */ {
 public:
  inline SendChatChannelMessageRequest() : SendChatChannelMessageRequest(nullptr) {}
  ~SendChatChannelMessageRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SendChatChannelMessageRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendChatChannelMessageRequest(const SendChatChannelMessageRequest& from);
  SendChatChannelMessageRequest(SendChatChannelMessageRequest&& from) noexcept
    : SendChatChannelMessageRequest() {
    *this = ::std::move(from);
  }

  inline SendChatChannelMessageRequest& operator=(const SendChatChannelMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendChatChannelMessageRequest& operator=(SendChatChannelMessageRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendChatChannelMessageRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendChatChannelMessageRequest* internal_default_instance() {
    return reinterpret_cast<const SendChatChannelMessageRequest*>(
               &_SendChatChannelMessageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SendChatChannelMessageRequest& a, SendChatChannelMessageRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SendChatChannelMessageRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendChatChannelMessageRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendChatChannelMessageRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendChatChannelMessageRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendChatChannelMessageRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SendChatChannelMessageRequest& from) {
    SendChatChannelMessageRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendChatChannelMessageRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sro.chat.SendChatChannelMessageRequest";
  }
  protected:
  explicit SendChatChannelMessageRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelIdFieldNumber = 1,
    kChatMessageFieldNumber = 2,
  };
  // string channel_id = 1;
  void clear_channel_id() ;
  const std::string& channel_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_channel_id(Arg_&& arg, Args_... args);
  std::string* mutable_channel_id();
  PROTOBUF_NODISCARD std::string* release_channel_id();
  void set_allocated_channel_id(std::string* ptr);

  private:
  const std::string& _internal_channel_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_channel_id(
      const std::string& value);
  std::string* _internal_mutable_channel_id();

  public:
  // .sro.chat.ChatMessage chat_message = 2;
  bool has_chat_message() const;
  void clear_chat_message() ;
  const ::sro::chat::ChatMessage& chat_message() const;
  PROTOBUF_NODISCARD ::sro::chat::ChatMessage* release_chat_message();
  ::sro::chat::ChatMessage* mutable_chat_message();
  void set_allocated_chat_message(::sro::chat::ChatMessage* chat_message);
  private:
  const ::sro::chat::ChatMessage& _internal_chat_message() const;
  ::sro::chat::ChatMessage* _internal_mutable_chat_message();
  public:
  void unsafe_arena_set_allocated_chat_message(
      ::sro::chat::ChatMessage* chat_message);
  ::sro::chat::ChatMessage* unsafe_arena_release_chat_message();
  // @@protoc_insertion_point(class_scope:sro.chat.SendChatChannelMessageRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr channel_id_;
    ::sro::chat::ChatMessage* chat_message_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sro_2fchat_2fchat_2eproto;
};// -------------------------------------------------------------------

class SendDirectMessageRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sro.chat.SendDirectMessageRequest) */ {
 public:
  inline SendDirectMessageRequest() : SendDirectMessageRequest(nullptr) {}
  ~SendDirectMessageRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SendDirectMessageRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendDirectMessageRequest(const SendDirectMessageRequest& from);
  SendDirectMessageRequest(SendDirectMessageRequest&& from) noexcept
    : SendDirectMessageRequest() {
    *this = ::std::move(from);
  }

  inline SendDirectMessageRequest& operator=(const SendDirectMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendDirectMessageRequest& operator=(SendDirectMessageRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendDirectMessageRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendDirectMessageRequest* internal_default_instance() {
    return reinterpret_cast<const SendDirectMessageRequest*>(
               &_SendDirectMessageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SendDirectMessageRequest& a, SendDirectMessageRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SendDirectMessageRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendDirectMessageRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendDirectMessageRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendDirectMessageRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendDirectMessageRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SendDirectMessageRequest& from) {
    SendDirectMessageRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendDirectMessageRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sro.chat.SendDirectMessageRequest";
  }
  protected:
  explicit SendDirectMessageRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCharacterIdFieldNumber = 1,
    kChatMessageFieldNumber = 2,
  };
  // string character_id = 1;
  void clear_character_id() ;
  const std::string& character_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_character_id(Arg_&& arg, Args_... args);
  std::string* mutable_character_id();
  PROTOBUF_NODISCARD std::string* release_character_id();
  void set_allocated_character_id(std::string* ptr);

  private:
  const std::string& _internal_character_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_character_id(
      const std::string& value);
  std::string* _internal_mutable_character_id();

  public:
  // .sro.chat.ChatMessage chat_message = 2;
  bool has_chat_message() const;
  void clear_chat_message() ;
  const ::sro::chat::ChatMessage& chat_message() const;
  PROTOBUF_NODISCARD ::sro::chat::ChatMessage* release_chat_message();
  ::sro::chat::ChatMessage* mutable_chat_message();
  void set_allocated_chat_message(::sro::chat::ChatMessage* chat_message);
  private:
  const ::sro::chat::ChatMessage& _internal_chat_message() const;
  ::sro::chat::ChatMessage* _internal_mutable_chat_message();
  public:
  void unsafe_arena_set_allocated_chat_message(
      ::sro::chat::ChatMessage* chat_message);
  ::sro::chat::ChatMessage* unsafe_arena_release_chat_message();
  // @@protoc_insertion_point(class_scope:sro.chat.SendDirectMessageRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr character_id_;
    ::sro::chat::ChatMessage* chat_message_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sro_2fchat_2fchat_2eproto;
};// -------------------------------------------------------------------

class UpdateChatChannelRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sro.chat.UpdateChatChannelRequest) */ {
 public:
  inline UpdateChatChannelRequest() : UpdateChatChannelRequest(nullptr) {}
  ~UpdateChatChannelRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateChatChannelRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateChatChannelRequest(const UpdateChatChannelRequest& from);
  UpdateChatChannelRequest(UpdateChatChannelRequest&& from) noexcept
    : UpdateChatChannelRequest() {
    *this = ::std::move(from);
  }

  inline UpdateChatChannelRequest& operator=(const UpdateChatChannelRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateChatChannelRequest& operator=(UpdateChatChannelRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateChatChannelRequest& default_instance() {
    return *internal_default_instance();
  }
  enum OptionalNameCase {
    kName = 2,
    OPTIONAL_NAME_NOT_SET = 0,
  };

  enum OptionalDimensionCase {
    kDimension = 3,
    OPTIONAL_DIMENSION_NOT_SET = 0,
  };

  enum OptionalPublicCase {
    kPublic = 4,
    OPTIONAL_PUBLIC_NOT_SET = 0,
  };

  static inline const UpdateChatChannelRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateChatChannelRequest*>(
               &_UpdateChatChannelRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(UpdateChatChannelRequest& a, UpdateChatChannelRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateChatChannelRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateChatChannelRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateChatChannelRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateChatChannelRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateChatChannelRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateChatChannelRequest& from) {
    UpdateChatChannelRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateChatChannelRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sro.chat.UpdateChatChannelRequest";
  }
  protected:
  explicit UpdateChatChannelRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kDimensionFieldNumber = 3,
    kPublicFieldNumber = 4,
  };
  // string channel_id = 1;
  void clear_channel_id() ;
  const std::string& channel_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_channel_id(Arg_&& arg, Args_... args);
  std::string* mutable_channel_id();
  PROTOBUF_NODISCARD std::string* release_channel_id();
  void set_allocated_channel_id(std::string* ptr);

  private:
  const std::string& _internal_channel_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_channel_id(
      const std::string& value);
  std::string* _internal_mutable_channel_id();

  public:
  // string name = 2;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string dimension = 3;
  bool has_dimension() const;
  void clear_dimension() ;
  const std::string& dimension() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dimension(Arg_&& arg, Args_... args);
  std::string* mutable_dimension();
  PROTOBUF_NODISCARD std::string* release_dimension();
  void set_allocated_dimension(std::string* ptr);

  private:
  const std::string& _internal_dimension() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dimension(
      const std::string& value);
  std::string* _internal_mutable_dimension();

  public:
  // bool public = 4;
  bool has_public_() const;
  void clear_public_() ;
  bool public_() const;
  void set_public_(bool value);

  private:
  bool _internal_public_() const;
  void _internal_set_public_(bool value);

  public:
  void clear_optional_name();
  OptionalNameCase optional_name_case() const;
  void clear_optional_dimension();
  OptionalDimensionCase optional_dimension_case() const;
  void clear_optional_public();
  OptionalPublicCase optional_public_case() const;
  // @@protoc_insertion_point(class_scope:sro.chat.UpdateChatChannelRequest)
 private:
  class _Internal;
  void set_has_name();
  void set_has_dimension();
  void set_has_public_();

  inline bool has_optional_name() const;
  inline void clear_has_optional_name();

  inline bool has_optional_dimension() const;
  inline void clear_has_optional_dimension();

  inline bool has_optional_public() const;
  inline void clear_has_optional_public();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr channel_id_;
    union OptionalNameUnion {
      constexpr OptionalNameUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    } optional_name_;
    union OptionalDimensionUnion {
      constexpr OptionalDimensionUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dimension_;
    } optional_dimension_;
    union OptionalPublicUnion {
      constexpr OptionalPublicUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      bool public__;
    } optional_public_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[3];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sro_2fchat_2fchat_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// ChatLogRequest

// string channel_id = 1;
inline void ChatLogRequest::clear_channel_id() {
  _impl_.channel_id_.ClearToEmpty();
}
inline const std::string& ChatLogRequest::channel_id() const {
  // @@protoc_insertion_point(field_get:sro.chat.ChatLogRequest.channel_id)
  return _internal_channel_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChatLogRequest::set_channel_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.channel_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.chat.ChatLogRequest.channel_id)
}
inline std::string* ChatLogRequest::mutable_channel_id() {
  std::string* _s = _internal_mutable_channel_id();
  // @@protoc_insertion_point(field_mutable:sro.chat.ChatLogRequest.channel_id)
  return _s;
}
inline const std::string& ChatLogRequest::_internal_channel_id() const {
  return _impl_.channel_id_.Get();
}
inline void ChatLogRequest::_internal_set_channel_id(const std::string& value) {
  ;


  _impl_.channel_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatLogRequest::_internal_mutable_channel_id() {
  ;
  return _impl_.channel_id_.Mutable( GetArenaForAllocation());
}
inline std::string* ChatLogRequest::release_channel_id() {
  // @@protoc_insertion_point(field_release:sro.chat.ChatLogRequest.channel_id)
  return _impl_.channel_id_.Release();
}
inline void ChatLogRequest::set_allocated_channel_id(std::string* value) {
  _impl_.channel_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.channel_id_.IsDefault()) {
          _impl_.channel_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sro.chat.ChatLogRequest.channel_id)
}

// string sender_id = 2;
inline bool ChatLogRequest::has_sender_id() const {
  return optional_sender_id_case() == kSenderId;
}
inline void ChatLogRequest::set_has_sender_id() {
  _impl_._oneof_case_[0] = kSenderId;
}
inline void ChatLogRequest::clear_sender_id() {
  if (optional_sender_id_case() == kSenderId) {
    _impl_.optional_sender_id_.sender_id_.Destroy();
    clear_has_optional_sender_id();
  }
}
inline const std::string& ChatLogRequest::sender_id() const {
  // @@protoc_insertion_point(field_get:sro.chat.ChatLogRequest.sender_id)
  return _internal_sender_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChatLogRequest::set_sender_id(Arg_&& arg,
                                                     Args_... args) {
  if (optional_sender_id_case() != kSenderId) {
    clear_optional_sender_id();

    set_has_sender_id();
    _impl_.optional_sender_id_.sender_id_.InitDefault();
  }
  _impl_.optional_sender_id_.sender_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.chat.ChatLogRequest.sender_id)
}
inline std::string* ChatLogRequest::mutable_sender_id() {
  std::string* _s = _internal_mutable_sender_id();
  // @@protoc_insertion_point(field_mutable:sro.chat.ChatLogRequest.sender_id)
  return _s;
}
inline const std::string& ChatLogRequest::_internal_sender_id() const {
  if (optional_sender_id_case() != kSenderId) {
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.optional_sender_id_.sender_id_.Get();
}
inline void ChatLogRequest::_internal_set_sender_id(const std::string& value) {
  if (optional_sender_id_case() != kSenderId) {
    clear_optional_sender_id();

    set_has_sender_id();
    _impl_.optional_sender_id_.sender_id_.InitDefault();
  }


  _impl_.optional_sender_id_.sender_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatLogRequest::_internal_mutable_sender_id() {
  if (optional_sender_id_case() != kSenderId) {
    clear_optional_sender_id();

    set_has_sender_id();
    _impl_.optional_sender_id_.sender_id_.InitDefault();
  }
  return _impl_.optional_sender_id_.sender_id_.Mutable( GetArenaForAllocation());
}
inline std::string* ChatLogRequest::release_sender_id() {
  // @@protoc_insertion_point(field_release:sro.chat.ChatLogRequest.sender_id)
  if (optional_sender_id_case() != kSenderId) {
    return nullptr;
  }
  clear_has_optional_sender_id();
  return _impl_.optional_sender_id_.sender_id_.Release();
}
inline void ChatLogRequest::set_allocated_sender_id(std::string* value) {
  if (has_optional_sender_id()) {
    clear_optional_sender_id();
  }
  if (value != nullptr) {
    set_has_sender_id();
    _impl_.optional_sender_id_.sender_id_.InitAllocated(value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:sro.chat.ChatLogRequest.sender_id)
}

// int64 before = 3;
inline bool ChatLogRequest::has_before() const {
  return optional_before_case() == kBefore;
}
inline void ChatLogRequest::set_has_before() {
  _impl_._oneof_case_[1] = kBefore;
}
inline void ChatLogRequest::clear_before() {
  if (optional_before_case() == kBefore) {
    _impl_.optional_before_.before_ = ::int64_t{0};
    clear_has_optional_before();
  }
}
inline ::int64_t ChatLogRequest::before() const {
  // @@protoc_insertion_point(field_get:sro.chat.ChatLogRequest.before)
  return _internal_before();
}
inline void ChatLogRequest::set_before(::int64_t value) {
  _internal_set_before(value);
  // @@protoc_insertion_point(field_set:sro.chat.ChatLogRequest.before)
}
inline ::int64_t ChatLogRequest::_internal_before() const {
  if (optional_before_case() == kBefore) {
    return _impl_.optional_before_.before_;
  }
  return ::int64_t{0};
}
inline void ChatLogRequest::_internal_set_before(::int64_t value) {
  if (optional_before_case() != kBefore) {
    clear_optional_before();
    set_has_before();
  }
  _impl_.optional_before_.before_ = value;
}

// int64 after = 4;
inline bool ChatLogRequest::has_after() const {
  return optional_after_case() == kAfter;
}
inline void ChatLogRequest::set_has_after() {
  _impl_._oneof_case_[2] = kAfter;
}
inline void ChatLogRequest::clear_after() {
  if (optional_after_case() == kAfter) {
    _impl_.optional_after_.after_ = ::int64_t{0};
    clear_has_optional_after();
  }
}
inline ::int64_t ChatLogRequest::after() const {
  // @@protoc_insertion_point(field_get:sro.chat.ChatLogRequest.after)
  return _internal_after();
}
inline void ChatLogRequest::set_after(::int64_t value) {
  _internal_set_after(value);
  // @@protoc_insertion_point(field_set:sro.chat.ChatLogRequest.after)
}
inline ::int64_t ChatLogRequest::_internal_after() const {
  if (optional_after_case() == kAfter) {
    return _impl_.optional_after_.after_;
  }
  return ::int64_t{0};
}
inline void ChatLogRequest::_internal_set_after(::int64_t value) {
  if (optional_after_case() != kAfter) {
    clear_optional_after();
    set_has_after();
  }
  _impl_.optional_after_.after_ = value;
}

// uint64 limit = 5;
inline bool ChatLogRequest::has_limit() const {
  return optional_limit_case() == kLimit;
}
inline void ChatLogRequest::set_has_limit() {
  _impl_._oneof_case_[3] = kLimit;
}
inline void ChatLogRequest::clear_limit() {
  if (optional_limit_case() == kLimit) {
    _impl_.optional_limit_.limit_ = ::uint64_t{0u};
    clear_has_optional_limit();
  }
}
inline ::uint64_t ChatLogRequest::limit() const {
  // @@protoc_insertion_point(field_get:sro.chat.ChatLogRequest.limit)
  return _internal_limit();
}
inline void ChatLogRequest::set_limit(::uint64_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:sro.chat.ChatLogRequest.limit)
}
inline ::uint64_t ChatLogRequest::_internal_limit() const {
  if (optional_limit_case() == kLimit) {
    return _impl_.optional_limit_.limit_;
  }
  return ::uint64_t{0u};
}
inline void ChatLogRequest::_internal_set_limit(::uint64_t value) {
  if (optional_limit_case() != kLimit) {
    clear_optional_limit();
    set_has_limit();
  }
  _impl_.optional_limit_.limit_ = value;
}

// uint64 offset = 6;
inline bool ChatLogRequest::has_offset() const {
  return optional_offset_case() == kOffset;
}
inline void ChatLogRequest::set_has_offset() {
  _impl_._oneof_case_[4] = kOffset;
}
inline void ChatLogRequest::clear_offset() {
  if (optional_offset_case() == kOffset) {
    _impl_.optional_offset_.offset_ = ::uint64_t{0u};
    clear_has_optional_offset();
  }
}
inline ::uint64_t ChatLogRequest::offset() const {
  // @@protoc_insertion_point(field_get:sro.chat.ChatLogRequest.offset)
  return _internal_offset();
}
inline void ChatLogRequest::set_offset(::uint64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:sro.chat.ChatLogRequest.offset)
}
inline ::uint64_t ChatLogRequest::_internal_offset() const {
  if (optional_offset_case() == kOffset) {
    return _impl_.optional_offset_.offset_;
  }
  return ::uint64_t{0u};
}
inline void ChatLogRequest::_internal_set_offset(::uint64_t value) {
  if (optional_offset_case() != kOffset) {
    clear_optional_offset();
    set_has_offset();
  }
  _impl_.optional_offset_.offset_ = value;
}

inline bool ChatLogRequest::has_optional_sender_id() const {
  return optional_sender_id_case() != OPTIONAL_SENDER_ID_NOT_SET;
}
inline void ChatLogRequest::clear_has_optional_sender_id() {
  _impl_._oneof_case_[0] = OPTIONAL_SENDER_ID_NOT_SET;
}
inline bool ChatLogRequest::has_optional_before() const {
  return optional_before_case() != OPTIONAL_BEFORE_NOT_SET;
}
inline void ChatLogRequest::clear_has_optional_before() {
  _impl_._oneof_case_[1] = OPTIONAL_BEFORE_NOT_SET;
}
inline bool ChatLogRequest::has_optional_after() const {
  return optional_after_case() != OPTIONAL_AFTER_NOT_SET;
}
inline void ChatLogRequest::clear_has_optional_after() {
  _impl_._oneof_case_[2] = OPTIONAL_AFTER_NOT_SET;
}
inline bool ChatLogRequest::has_optional_limit() const {
  return optional_limit_case() != OPTIONAL_LIMIT_NOT_SET;
}
inline void ChatLogRequest::clear_has_optional_limit() {
  _impl_._oneof_case_[3] = OPTIONAL_LIMIT_NOT_SET;
}
inline bool ChatLogRequest::has_optional_offset() const {
  return optional_offset_case() != OPTIONAL_OFFSET_NOT_SET;
}
inline void ChatLogRequest::clear_has_optional_offset() {
  _impl_._oneof_case_[4] = OPTIONAL_OFFSET_NOT_SET;
}
inline ChatLogRequest::OptionalSenderIdCase ChatLogRequest::optional_sender_id_case() const {
  return ChatLogRequest::OptionalSenderIdCase(_impl_._oneof_case_[0]);
}
inline ChatLogRequest::OptionalBeforeCase ChatLogRequest::optional_before_case() const {
  return ChatLogRequest::OptionalBeforeCase(_impl_._oneof_case_[1]);
}
inline ChatLogRequest::OptionalAfterCase ChatLogRequest::optional_after_case() const {
  return ChatLogRequest::OptionalAfterCase(_impl_._oneof_case_[2]);
}
inline ChatLogRequest::OptionalLimitCase ChatLogRequest::optional_limit_case() const {
  return ChatLogRequest::OptionalLimitCase(_impl_._oneof_case_[3]);
}
inline ChatLogRequest::OptionalOffsetCase ChatLogRequest::optional_offset_case() const {
  return ChatLogRequest::OptionalOffsetCase(_impl_._oneof_case_[4]);
}
// -------------------------------------------------------------------

// ChatLog

// uint64 sent_at = 1;
inline void ChatLog::clear_sent_at() {
  _impl_.sent_at_ = ::uint64_t{0u};
}
inline ::uint64_t ChatLog::sent_at() const {
  // @@protoc_insertion_point(field_get:sro.chat.ChatLog.sent_at)
  return _internal_sent_at();
}
inline void ChatLog::set_sent_at(::uint64_t value) {
  _internal_set_sent_at(value);
  // @@protoc_insertion_point(field_set:sro.chat.ChatLog.sent_at)
}
inline ::uint64_t ChatLog::_internal_sent_at() const {
  return _impl_.sent_at_;
}
inline void ChatLog::_internal_set_sent_at(::uint64_t value) {
  ;
  _impl_.sent_at_ = value;
}

// string channel_id = 2;
inline void ChatLog::clear_channel_id() {
  _impl_.channel_id_.ClearToEmpty();
}
inline const std::string& ChatLog::channel_id() const {
  // @@protoc_insertion_point(field_get:sro.chat.ChatLog.channel_id)
  return _internal_channel_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChatLog::set_channel_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.channel_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.chat.ChatLog.channel_id)
}
inline std::string* ChatLog::mutable_channel_id() {
  std::string* _s = _internal_mutable_channel_id();
  // @@protoc_insertion_point(field_mutable:sro.chat.ChatLog.channel_id)
  return _s;
}
inline const std::string& ChatLog::_internal_channel_id() const {
  return _impl_.channel_id_.Get();
}
inline void ChatLog::_internal_set_channel_id(const std::string& value) {
  ;


  _impl_.channel_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatLog::_internal_mutable_channel_id() {
  ;
  return _impl_.channel_id_.Mutable( GetArenaForAllocation());
}
inline std::string* ChatLog::release_channel_id() {
  // @@protoc_insertion_point(field_release:sro.chat.ChatLog.channel_id)
  return _impl_.channel_id_.Release();
}
inline void ChatLog::set_allocated_channel_id(std::string* value) {
  _impl_.channel_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.channel_id_.IsDefault()) {
          _impl_.channel_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sro.chat.ChatLog.channel_id)
}

// string sender_id = 3;
inline void ChatLog::clear_sender_id() {
  _impl_.sender_id_.ClearToEmpty();
}
inline const std::string& ChatLog::sender_id() const {
  // @@protoc_insertion_point(field_get:sro.chat.ChatLog.sender_id)
  return _internal_sender_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChatLog::set_sender_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.chat.ChatLog.sender_id)
}
inline std::string* ChatLog::mutable_sender_id() {
  std::string* _s = _internal_mutable_sender_id();
  // @@protoc_insertion_point(field_mutable:sro.chat.ChatLog.sender_id)
  return _s;
}
inline const std::string& ChatLog::_internal_sender_id() const {
  return _impl_.sender_id_.Get();
}
inline void ChatLog::_internal_set_sender_id(const std::string& value) {
  ;


  _impl_.sender_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatLog::_internal_mutable_sender_id() {
  ;
  return _impl_.sender_id_.Mutable( GetArenaForAllocation());
}
inline std::string* ChatLog::release_sender_id() {
  // @@protoc_insertion_point(field_release:sro.chat.ChatLog.sender_id)
  return _impl_.sender_id_.Release();
}
inline void ChatLog::set_allocated_sender_id(std::string* value) {
  _impl_.sender_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_id_.IsDefault()) {
          _impl_.sender_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sro.chat.ChatLog.sender_id)
}

// string content = 4;
inline void ChatLog::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& ChatLog::content() const {
  // @@protoc_insertion_point(field_get:sro.chat.ChatLog.content)
  return _internal_content();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChatLog::set_content(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.content_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.chat.ChatLog.content)
}
inline std::string* ChatLog::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:sro.chat.ChatLog.content)
  return _s;
}
inline const std::string& ChatLog::_internal_content() const {
  return _impl_.content_.Get();
}
inline void ChatLog::_internal_set_content(const std::string& value) {
  ;


  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatLog::_internal_mutable_content() {
  ;
  return _impl_.content_.Mutable( GetArenaForAllocation());
}
inline std::string* ChatLog::release_content() {
  // @@protoc_insertion_point(field_release:sro.chat.ChatLog.content)
  return _impl_.content_.Release();
}
inline void ChatLog::set_allocated_content(std::string* value) {
  _impl_.content_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.content_.IsDefault()) {
          _impl_.content_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sro.chat.ChatLog.content)
}

// -------------------------------------------------------------------

// ChatLogs

// uint64 total = 1;
inline void ChatLogs::clear_total() {
  _impl_.total_ = ::uint64_t{0u};
}
inline ::uint64_t ChatLogs::total() const {
  // @@protoc_insertion_point(field_get:sro.chat.ChatLogs.total)
  return _internal_total();
}
inline void ChatLogs::set_total(::uint64_t value) {
  _internal_set_total(value);
  // @@protoc_insertion_point(field_set:sro.chat.ChatLogs.total)
}
inline ::uint64_t ChatLogs::_internal_total() const {
  return _impl_.total_;
}
inline void ChatLogs::_internal_set_total(::uint64_t value) {
  ;
  _impl_.total_ = value;
}

// repeated .sro.chat.ChatLog logs = 2;
inline int ChatLogs::_internal_logs_size() const {
  return _impl_.logs_.size();
}
inline int ChatLogs::logs_size() const {
  return _internal_logs_size();
}
inline void ChatLogs::clear_logs() {
  _internal_mutable_logs()->Clear();
}
inline ::sro::chat::ChatLog* ChatLogs::mutable_logs(int index) {
  // @@protoc_insertion_point(field_mutable:sro.chat.ChatLogs.logs)
  return _internal_mutable_logs()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::chat::ChatLog >*
ChatLogs::mutable_logs() {
  // @@protoc_insertion_point(field_mutable_list:sro.chat.ChatLogs.logs)
  return _internal_mutable_logs();
}
inline const ::sro::chat::ChatLog& ChatLogs::_internal_logs(int index) const {
  return _internal_logs().Get(index);
}
inline const ::sro::chat::ChatLog& ChatLogs::logs(int index) const {
  // @@protoc_insertion_point(field_get:sro.chat.ChatLogs.logs)
  return _internal_logs(index);
}
inline ::sro::chat::ChatLog* ChatLogs::_internal_add_logs() {
  return _internal_mutable_logs()->Add();
}
inline ::sro::chat::ChatLog* ChatLogs::add_logs() {
  ::sro::chat::ChatLog* _add = _internal_add_logs();
  // @@protoc_insertion_point(field_add:sro.chat.ChatLogs.logs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::chat::ChatLog >&
ChatLogs::logs() const {
  // @@protoc_insertion_point(field_list:sro.chat.ChatLogs.logs)
  return _internal_logs();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sro::chat::ChatLog>&
ChatLogs::_internal_logs() const {
  return _impl_.logs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sro::chat::ChatLog>*
ChatLogs::_internal_mutable_logs() {
  return &_impl_.logs_;
}

// -------------------------------------------------------------------

// BanRequest

// string character_id = 1;
inline void BanRequest::clear_character_id() {
  _impl_.character_id_.ClearToEmpty();
}
inline const std::string& BanRequest::character_id() const {
  // @@protoc_insertion_point(field_get:sro.chat.BanRequest.character_id)
  return _internal_character_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BanRequest::set_character_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.character_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.chat.BanRequest.character_id)
}
inline std::string* BanRequest::mutable_character_id() {
  std::string* _s = _internal_mutable_character_id();
  // @@protoc_insertion_point(field_mutable:sro.chat.BanRequest.character_id)
  return _s;
}
inline const std::string& BanRequest::_internal_character_id() const {
  return _impl_.character_id_.Get();
}
inline void BanRequest::_internal_set_character_id(const std::string& value) {
  ;


  _impl_.character_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BanRequest::_internal_mutable_character_id() {
  ;
  return _impl_.character_id_.Mutable( GetArenaForAllocation());
}
inline std::string* BanRequest::release_character_id() {
  // @@protoc_insertion_point(field_release:sro.chat.BanRequest.character_id)
  return _impl_.character_id_.Release();
}
inline void BanRequest::set_allocated_character_id(std::string* value) {
  _impl_.character_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.character_id_.IsDefault()) {
          _impl_.character_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sro.chat.BanRequest.character_id)
}

// string channel_id = 2;
inline void BanRequest::clear_channel_id() {
  _impl_.channel_id_.ClearToEmpty();
}
inline const std::string& BanRequest::channel_id() const {
  // @@protoc_insertion_point(field_get:sro.chat.BanRequest.channel_id)
  return _internal_channel_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BanRequest::set_channel_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.channel_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.chat.BanRequest.channel_id)
}
inline std::string* BanRequest::mutable_channel_id() {
  std::string* _s = _internal_mutable_channel_id();
  // @@protoc_insertion_point(field_mutable:sro.chat.BanRequest.channel_id)
  return _s;
}
inline const std::string& BanRequest::_internal_channel_id() const {
  return _impl_.channel_id_.Get();
}
inline void BanRequest::_internal_set_channel_id(const std::string& value) {
  ;


  _impl_.channel_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BanRequest::_internal_mutable_channel_id() {
  ;
  return _impl_.channel_id_.Mutable( GetArenaForAllocation());
}
inline std::string* BanRequest::release_channel_id() {
  // @@protoc_insertion_point(field_release:sro.chat.BanRequest.channel_id)
  return _impl_.channel_id_.Release();
}
inline void BanRequest::set_allocated_channel_id(std::string* value) {
  _impl_.channel_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.channel_id_.IsDefault()) {
          _impl_.channel_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sro.chat.BanRequest.channel_id)
}

// int64 duration = 3;
inline void BanRequest::clear_duration() {
  _impl_.duration_ = ::int64_t{0};
}
inline ::int64_t BanRequest::duration() const {
  // @@protoc_insertion_point(field_get:sro.chat.BanRequest.duration)
  return _internal_duration();
}
inline void BanRequest::set_duration(::int64_t value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:sro.chat.BanRequest.duration)
}
inline ::int64_t BanRequest::_internal_duration() const {
  return _impl_.duration_;
}
inline void BanRequest::_internal_set_duration(::int64_t value) {
  ;
  _impl_.duration_ = value;
}

// -------------------------------------------------------------------

// ConnectChatChannelRequest

// string channel_id = 1;
inline void ConnectChatChannelRequest::clear_channel_id() {
  _impl_.channel_id_.ClearToEmpty();
}
inline const std::string& ConnectChatChannelRequest::channel_id() const {
  // @@protoc_insertion_point(field_get:sro.chat.ConnectChatChannelRequest.channel_id)
  return _internal_channel_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ConnectChatChannelRequest::set_channel_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.channel_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.chat.ConnectChatChannelRequest.channel_id)
}
inline std::string* ConnectChatChannelRequest::mutable_channel_id() {
  std::string* _s = _internal_mutable_channel_id();
  // @@protoc_insertion_point(field_mutable:sro.chat.ConnectChatChannelRequest.channel_id)
  return _s;
}
inline const std::string& ConnectChatChannelRequest::_internal_channel_id() const {
  return _impl_.channel_id_.Get();
}
inline void ConnectChatChannelRequest::_internal_set_channel_id(const std::string& value) {
  ;


  _impl_.channel_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ConnectChatChannelRequest::_internal_mutable_channel_id() {
  ;
  return _impl_.channel_id_.Mutable( GetArenaForAllocation());
}
inline std::string* ConnectChatChannelRequest::release_channel_id() {
  // @@protoc_insertion_point(field_release:sro.chat.ConnectChatChannelRequest.channel_id)
  return _impl_.channel_id_.Release();
}
inline void ConnectChatChannelRequest::set_allocated_channel_id(std::string* value) {
  _impl_.channel_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.channel_id_.IsDefault()) {
          _impl_.channel_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sro.chat.ConnectChatChannelRequest.channel_id)
}

// string character_id = 2;
inline void ConnectChatChannelRequest::clear_character_id() {
  _impl_.character_id_.ClearToEmpty();
}
inline const std::string& ConnectChatChannelRequest::character_id() const {
  // @@protoc_insertion_point(field_get:sro.chat.ConnectChatChannelRequest.character_id)
  return _internal_character_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ConnectChatChannelRequest::set_character_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.character_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.chat.ConnectChatChannelRequest.character_id)
}
inline std::string* ConnectChatChannelRequest::mutable_character_id() {
  std::string* _s = _internal_mutable_character_id();
  // @@protoc_insertion_point(field_mutable:sro.chat.ConnectChatChannelRequest.character_id)
  return _s;
}
inline const std::string& ConnectChatChannelRequest::_internal_character_id() const {
  return _impl_.character_id_.Get();
}
inline void ConnectChatChannelRequest::_internal_set_character_id(const std::string& value) {
  ;


  _impl_.character_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ConnectChatChannelRequest::_internal_mutable_character_id() {
  ;
  return _impl_.character_id_.Mutable( GetArenaForAllocation());
}
inline std::string* ConnectChatChannelRequest::release_character_id() {
  // @@protoc_insertion_point(field_release:sro.chat.ConnectChatChannelRequest.character_id)
  return _impl_.character_id_.Release();
}
inline void ConnectChatChannelRequest::set_allocated_character_id(std::string* value) {
  _impl_.character_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.character_id_.IsDefault()) {
          _impl_.character_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sro.chat.ConnectChatChannelRequest.character_id)
}

// -------------------------------------------------------------------

// RequestSetCharacterSetChatChannelAuth

// string character_id = 1;
inline void RequestSetCharacterSetChatChannelAuth::clear_character_id() {
  _impl_.character_id_.ClearToEmpty();
}
inline const std::string& RequestSetCharacterSetChatChannelAuth::character_id() const {
  // @@protoc_insertion_point(field_get:sro.chat.RequestSetCharacterSetChatChannelAuth.character_id)
  return _internal_character_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RequestSetCharacterSetChatChannelAuth::set_character_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.character_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.chat.RequestSetCharacterSetChatChannelAuth.character_id)
}
inline std::string* RequestSetCharacterSetChatChannelAuth::mutable_character_id() {
  std::string* _s = _internal_mutable_character_id();
  // @@protoc_insertion_point(field_mutable:sro.chat.RequestSetCharacterSetChatChannelAuth.character_id)
  return _s;
}
inline const std::string& RequestSetCharacterSetChatChannelAuth::_internal_character_id() const {
  return _impl_.character_id_.Get();
}
inline void RequestSetCharacterSetChatChannelAuth::_internal_set_character_id(const std::string& value) {
  ;


  _impl_.character_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestSetCharacterSetChatChannelAuth::_internal_mutable_character_id() {
  ;
  return _impl_.character_id_.Mutable( GetArenaForAllocation());
}
inline std::string* RequestSetCharacterSetChatChannelAuth::release_character_id() {
  // @@protoc_insertion_point(field_release:sro.chat.RequestSetCharacterSetChatChannelAuth.character_id)
  return _impl_.character_id_.Release();
}
inline void RequestSetCharacterSetChatChannelAuth::set_allocated_character_id(std::string* value) {
  _impl_.character_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.character_id_.IsDefault()) {
          _impl_.character_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sro.chat.RequestSetCharacterSetChatChannelAuth.character_id)
}

// repeated string ids = 2;
inline int RequestSetCharacterSetChatChannelAuth::_internal_ids_size() const {
  return _impl_.ids_.size();
}
inline int RequestSetCharacterSetChatChannelAuth::ids_size() const {
  return _internal_ids_size();
}
inline void RequestSetCharacterSetChatChannelAuth::clear_ids() {
  _internal_mutable_ids()->Clear();
}
inline std::string* RequestSetCharacterSetChatChannelAuth::add_ids() {
  std::string* _s = _internal_add_ids();
  // @@protoc_insertion_point(field_add_mutable:sro.chat.RequestSetCharacterSetChatChannelAuth.ids)
  return _s;
}
inline const std::string& RequestSetCharacterSetChatChannelAuth::ids(int index) const {
  // @@protoc_insertion_point(field_get:sro.chat.RequestSetCharacterSetChatChannelAuth.ids)
  return _internal_ids(index);
}
inline std::string* RequestSetCharacterSetChatChannelAuth::mutable_ids(int index) {
  // @@protoc_insertion_point(field_mutable:sro.chat.RequestSetCharacterSetChatChannelAuth.ids)
  return _internal_mutable_ids()->Mutable(index);
}
inline void RequestSetCharacterSetChatChannelAuth::set_ids(int index, const std::string& value) {
  _internal_mutable_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:sro.chat.RequestSetCharacterSetChatChannelAuth.ids)
}
inline void RequestSetCharacterSetChatChannelAuth::set_ids(int index, std::string&& value) {
  _internal_mutable_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:sro.chat.RequestSetCharacterSetChatChannelAuth.ids)
}
inline void RequestSetCharacterSetChatChannelAuth::set_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sro.chat.RequestSetCharacterSetChatChannelAuth.ids)
}
inline void RequestSetCharacterSetChatChannelAuth::set_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sro.chat.RequestSetCharacterSetChatChannelAuth.ids)
}
inline void RequestSetCharacterSetChatChannelAuth::set_ids(int index, absl::string_view value) {
  _internal_mutable_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:sro.chat.RequestSetCharacterSetChatChannelAuth.ids)
}
inline void RequestSetCharacterSetChatChannelAuth::add_ids(const std::string& value) {
  _internal_mutable_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:sro.chat.RequestSetCharacterSetChatChannelAuth.ids)
}
inline void RequestSetCharacterSetChatChannelAuth::add_ids(std::string&& value) {
  _internal_mutable_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:sro.chat.RequestSetCharacterSetChatChannelAuth.ids)
}
inline void RequestSetCharacterSetChatChannelAuth::add_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sro.chat.RequestSetCharacterSetChatChannelAuth.ids)
}
inline void RequestSetCharacterSetChatChannelAuth::add_ids(const char* value, std::size_t size) {
  _internal_mutable_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sro.chat.RequestSetCharacterSetChatChannelAuth.ids)
}
inline void RequestSetCharacterSetChatChannelAuth::add_ids(absl::string_view value) {
  _internal_mutable_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:sro.chat.RequestSetCharacterSetChatChannelAuth.ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RequestSetCharacterSetChatChannelAuth::ids() const {
  // @@protoc_insertion_point(field_list:sro.chat.RequestSetCharacterSetChatChannelAuth.ids)
  return _internal_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* RequestSetCharacterSetChatChannelAuth::mutable_ids() {
  // @@protoc_insertion_point(field_mutable_list:sro.chat.RequestSetCharacterSetChatChannelAuth.ids)
  return _internal_mutable_ids();
}
inline const std::string& RequestSetCharacterSetChatChannelAuth::_internal_ids(int index) const {
  return _internal_ids().Get(index);
}
inline std::string* RequestSetCharacterSetChatChannelAuth::_internal_add_ids() {
  return _internal_mutable_ids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RequestSetCharacterSetChatChannelAuth::_internal_ids() const {
  return _impl_.ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RequestSetCharacterSetChatChannelAuth::_internal_mutable_ids() {
  return &_impl_.ids_;
}

// -------------------------------------------------------------------

// RequestUpdateCharacterSetChatChannelAuth

// string character_id = 1;
inline void RequestUpdateCharacterSetChatChannelAuth::clear_character_id() {
  _impl_.character_id_.ClearToEmpty();
}
inline const std::string& RequestUpdateCharacterSetChatChannelAuth::character_id() const {
  // @@protoc_insertion_point(field_get:sro.chat.RequestUpdateCharacterSetChatChannelAuth.character_id)
  return _internal_character_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RequestUpdateCharacterSetChatChannelAuth::set_character_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.character_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.chat.RequestUpdateCharacterSetChatChannelAuth.character_id)
}
inline std::string* RequestUpdateCharacterSetChatChannelAuth::mutable_character_id() {
  std::string* _s = _internal_mutable_character_id();
  // @@protoc_insertion_point(field_mutable:sro.chat.RequestUpdateCharacterSetChatChannelAuth.character_id)
  return _s;
}
inline const std::string& RequestUpdateCharacterSetChatChannelAuth::_internal_character_id() const {
  return _impl_.character_id_.Get();
}
inline void RequestUpdateCharacterSetChatChannelAuth::_internal_set_character_id(const std::string& value) {
  ;


  _impl_.character_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestUpdateCharacterSetChatChannelAuth::_internal_mutable_character_id() {
  ;
  return _impl_.character_id_.Mutable( GetArenaForAllocation());
}
inline std::string* RequestUpdateCharacterSetChatChannelAuth::release_character_id() {
  // @@protoc_insertion_point(field_release:sro.chat.RequestUpdateCharacterSetChatChannelAuth.character_id)
  return _impl_.character_id_.Release();
}
inline void RequestUpdateCharacterSetChatChannelAuth::set_allocated_character_id(std::string* value) {
  _impl_.character_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.character_id_.IsDefault()) {
          _impl_.character_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sro.chat.RequestUpdateCharacterSetChatChannelAuth.character_id)
}

// bool add = 2;
inline void RequestUpdateCharacterSetChatChannelAuth::clear_add() {
  _impl_.add_ = false;
}
inline bool RequestUpdateCharacterSetChatChannelAuth::add() const {
  // @@protoc_insertion_point(field_get:sro.chat.RequestUpdateCharacterSetChatChannelAuth.add)
  return _internal_add();
}
inline void RequestUpdateCharacterSetChatChannelAuth::set_add(bool value) {
  _internal_set_add(value);
  // @@protoc_insertion_point(field_set:sro.chat.RequestUpdateCharacterSetChatChannelAuth.add)
}
inline bool RequestUpdateCharacterSetChatChannelAuth::_internal_add() const {
  return _impl_.add_;
}
inline void RequestUpdateCharacterSetChatChannelAuth::_internal_set_add(bool value) {
  ;
  _impl_.add_ = value;
}

// repeated string ids = 3;
inline int RequestUpdateCharacterSetChatChannelAuth::_internal_ids_size() const {
  return _impl_.ids_.size();
}
inline int RequestUpdateCharacterSetChatChannelAuth::ids_size() const {
  return _internal_ids_size();
}
inline void RequestUpdateCharacterSetChatChannelAuth::clear_ids() {
  _internal_mutable_ids()->Clear();
}
inline std::string* RequestUpdateCharacterSetChatChannelAuth::add_ids() {
  std::string* _s = _internal_add_ids();
  // @@protoc_insertion_point(field_add_mutable:sro.chat.RequestUpdateCharacterSetChatChannelAuth.ids)
  return _s;
}
inline const std::string& RequestUpdateCharacterSetChatChannelAuth::ids(int index) const {
  // @@protoc_insertion_point(field_get:sro.chat.RequestUpdateCharacterSetChatChannelAuth.ids)
  return _internal_ids(index);
}
inline std::string* RequestUpdateCharacterSetChatChannelAuth::mutable_ids(int index) {
  // @@protoc_insertion_point(field_mutable:sro.chat.RequestUpdateCharacterSetChatChannelAuth.ids)
  return _internal_mutable_ids()->Mutable(index);
}
inline void RequestUpdateCharacterSetChatChannelAuth::set_ids(int index, const std::string& value) {
  _internal_mutable_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:sro.chat.RequestUpdateCharacterSetChatChannelAuth.ids)
}
inline void RequestUpdateCharacterSetChatChannelAuth::set_ids(int index, std::string&& value) {
  _internal_mutable_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:sro.chat.RequestUpdateCharacterSetChatChannelAuth.ids)
}
inline void RequestUpdateCharacterSetChatChannelAuth::set_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sro.chat.RequestUpdateCharacterSetChatChannelAuth.ids)
}
inline void RequestUpdateCharacterSetChatChannelAuth::set_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sro.chat.RequestUpdateCharacterSetChatChannelAuth.ids)
}
inline void RequestUpdateCharacterSetChatChannelAuth::set_ids(int index, absl::string_view value) {
  _internal_mutable_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:sro.chat.RequestUpdateCharacterSetChatChannelAuth.ids)
}
inline void RequestUpdateCharacterSetChatChannelAuth::add_ids(const std::string& value) {
  _internal_mutable_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:sro.chat.RequestUpdateCharacterSetChatChannelAuth.ids)
}
inline void RequestUpdateCharacterSetChatChannelAuth::add_ids(std::string&& value) {
  _internal_mutable_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:sro.chat.RequestUpdateCharacterSetChatChannelAuth.ids)
}
inline void RequestUpdateCharacterSetChatChannelAuth::add_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sro.chat.RequestUpdateCharacterSetChatChannelAuth.ids)
}
inline void RequestUpdateCharacterSetChatChannelAuth::add_ids(const char* value, std::size_t size) {
  _internal_mutable_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sro.chat.RequestUpdateCharacterSetChatChannelAuth.ids)
}
inline void RequestUpdateCharacterSetChatChannelAuth::add_ids(absl::string_view value) {
  _internal_mutable_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:sro.chat.RequestUpdateCharacterSetChatChannelAuth.ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RequestUpdateCharacterSetChatChannelAuth::ids() const {
  // @@protoc_insertion_point(field_list:sro.chat.RequestUpdateCharacterSetChatChannelAuth.ids)
  return _internal_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* RequestUpdateCharacterSetChatChannelAuth::mutable_ids() {
  // @@protoc_insertion_point(field_mutable_list:sro.chat.RequestUpdateCharacterSetChatChannelAuth.ids)
  return _internal_mutable_ids();
}
inline const std::string& RequestUpdateCharacterSetChatChannelAuth::_internal_ids(int index) const {
  return _internal_ids().Get(index);
}
inline std::string* RequestUpdateCharacterSetChatChannelAuth::_internal_add_ids() {
  return _internal_mutable_ids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RequestUpdateCharacterSetChatChannelAuth::_internal_ids() const {
  return _impl_.ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RequestUpdateCharacterSetChatChannelAuth::_internal_mutable_ids() {
  return &_impl_.ids_;
}

// -------------------------------------------------------------------

// ChatChannel

// string id = 1;
inline void ChatChannel::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ChatChannel::id() const {
  // @@protoc_insertion_point(field_get:sro.chat.ChatChannel.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChatChannel::set_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.chat.ChatChannel.id)
}
inline std::string* ChatChannel::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:sro.chat.ChatChannel.id)
  return _s;
}
inline const std::string& ChatChannel::_internal_id() const {
  return _impl_.id_.Get();
}
inline void ChatChannel::_internal_set_id(const std::string& value) {
  ;


  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatChannel::_internal_mutable_id() {
  ;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* ChatChannel::release_id() {
  // @@protoc_insertion_point(field_release:sro.chat.ChatChannel.id)
  return _impl_.id_.Release();
}
inline void ChatChannel::set_allocated_id(std::string* value) {
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sro.chat.ChatChannel.id)
}

// string name = 2;
inline void ChatChannel::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ChatChannel::name() const {
  // @@protoc_insertion_point(field_get:sro.chat.ChatChannel.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChatChannel::set_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.chat.ChatChannel.name)
}
inline std::string* ChatChannel::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:sro.chat.ChatChannel.name)
  return _s;
}
inline const std::string& ChatChannel::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ChatChannel::_internal_set_name(const std::string& value) {
  ;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatChannel::_internal_mutable_name() {
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* ChatChannel::release_name() {
  // @@protoc_insertion_point(field_release:sro.chat.ChatChannel.name)
  return _impl_.name_.Release();
}
inline void ChatChannel::set_allocated_name(std::string* value) {
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sro.chat.ChatChannel.name)
}

// string dimension_id = 3;
inline void ChatChannel::clear_dimension_id() {
  _impl_.dimension_id_.ClearToEmpty();
}
inline const std::string& ChatChannel::dimension_id() const {
  // @@protoc_insertion_point(field_get:sro.chat.ChatChannel.dimension_id)
  return _internal_dimension_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChatChannel::set_dimension_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.dimension_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.chat.ChatChannel.dimension_id)
}
inline std::string* ChatChannel::mutable_dimension_id() {
  std::string* _s = _internal_mutable_dimension_id();
  // @@protoc_insertion_point(field_mutable:sro.chat.ChatChannel.dimension_id)
  return _s;
}
inline const std::string& ChatChannel::_internal_dimension_id() const {
  return _impl_.dimension_id_.Get();
}
inline void ChatChannel::_internal_set_dimension_id(const std::string& value) {
  ;


  _impl_.dimension_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatChannel::_internal_mutable_dimension_id() {
  ;
  return _impl_.dimension_id_.Mutable( GetArenaForAllocation());
}
inline std::string* ChatChannel::release_dimension_id() {
  // @@protoc_insertion_point(field_release:sro.chat.ChatChannel.dimension_id)
  return _impl_.dimension_id_.Release();
}
inline void ChatChannel::set_allocated_dimension_id(std::string* value) {
  _impl_.dimension_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dimension_id_.IsDefault()) {
          _impl_.dimension_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sro.chat.ChatChannel.dimension_id)
}

// bool public = 4;
inline void ChatChannel::clear_public_() {
  _impl_.public__ = false;
}
inline bool ChatChannel::public_() const {
  // @@protoc_insertion_point(field_get:sro.chat.ChatChannel.public)
  return _internal_public_();
}
inline void ChatChannel::set_public_(bool value) {
  _internal_set_public_(value);
  // @@protoc_insertion_point(field_set:sro.chat.ChatChannel.public)
}
inline bool ChatChannel::_internal_public_() const {
  return _impl_.public__;
}
inline void ChatChannel::_internal_set_public_(bool value) {
  ;
  _impl_.public__ = value;
}

// -------------------------------------------------------------------

// ChatChannels

// repeated .sro.chat.ChatChannel channels = 1;
inline int ChatChannels::_internal_channels_size() const {
  return _impl_.channels_.size();
}
inline int ChatChannels::channels_size() const {
  return _internal_channels_size();
}
inline void ChatChannels::clear_channels() {
  _internal_mutable_channels()->Clear();
}
inline ::sro::chat::ChatChannel* ChatChannels::mutable_channels(int index) {
  // @@protoc_insertion_point(field_mutable:sro.chat.ChatChannels.channels)
  return _internal_mutable_channels()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::chat::ChatChannel >*
ChatChannels::mutable_channels() {
  // @@protoc_insertion_point(field_mutable_list:sro.chat.ChatChannels.channels)
  return _internal_mutable_channels();
}
inline const ::sro::chat::ChatChannel& ChatChannels::_internal_channels(int index) const {
  return _internal_channels().Get(index);
}
inline const ::sro::chat::ChatChannel& ChatChannels::channels(int index) const {
  // @@protoc_insertion_point(field_get:sro.chat.ChatChannels.channels)
  return _internal_channels(index);
}
inline ::sro::chat::ChatChannel* ChatChannels::_internal_add_channels() {
  return _internal_mutable_channels()->Add();
}
inline ::sro::chat::ChatChannel* ChatChannels::add_channels() {
  ::sro::chat::ChatChannel* _add = _internal_add_channels();
  // @@protoc_insertion_point(field_add:sro.chat.ChatChannels.channels)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::chat::ChatChannel >&
ChatChannels::channels() const {
  // @@protoc_insertion_point(field_list:sro.chat.ChatChannels.channels)
  return _internal_channels();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sro::chat::ChatChannel>&
ChatChannels::_internal_channels() const {
  return _impl_.channels_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sro::chat::ChatChannel>*
ChatChannels::_internal_mutable_channels() {
  return &_impl_.channels_;
}

// -------------------------------------------------------------------

// CreateChatChannelMessage

// string name = 1;
inline void CreateChatChannelMessage::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CreateChatChannelMessage::name() const {
  // @@protoc_insertion_point(field_get:sro.chat.CreateChatChannelMessage.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateChatChannelMessage::set_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.chat.CreateChatChannelMessage.name)
}
inline std::string* CreateChatChannelMessage::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:sro.chat.CreateChatChannelMessage.name)
  return _s;
}
inline const std::string& CreateChatChannelMessage::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CreateChatChannelMessage::_internal_set_name(const std::string& value) {
  ;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateChatChannelMessage::_internal_mutable_name() {
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* CreateChatChannelMessage::release_name() {
  // @@protoc_insertion_point(field_release:sro.chat.CreateChatChannelMessage.name)
  return _impl_.name_.Release();
}
inline void CreateChatChannelMessage::set_allocated_name(std::string* value) {
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sro.chat.CreateChatChannelMessage.name)
}

// string dimension_id = 2;
inline void CreateChatChannelMessage::clear_dimension_id() {
  _impl_.dimension_id_.ClearToEmpty();
}
inline const std::string& CreateChatChannelMessage::dimension_id() const {
  // @@protoc_insertion_point(field_get:sro.chat.CreateChatChannelMessage.dimension_id)
  return _internal_dimension_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateChatChannelMessage::set_dimension_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.dimension_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.chat.CreateChatChannelMessage.dimension_id)
}
inline std::string* CreateChatChannelMessage::mutable_dimension_id() {
  std::string* _s = _internal_mutable_dimension_id();
  // @@protoc_insertion_point(field_mutable:sro.chat.CreateChatChannelMessage.dimension_id)
  return _s;
}
inline const std::string& CreateChatChannelMessage::_internal_dimension_id() const {
  return _impl_.dimension_id_.Get();
}
inline void CreateChatChannelMessage::_internal_set_dimension_id(const std::string& value) {
  ;


  _impl_.dimension_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateChatChannelMessage::_internal_mutable_dimension_id() {
  ;
  return _impl_.dimension_id_.Mutable( GetArenaForAllocation());
}
inline std::string* CreateChatChannelMessage::release_dimension_id() {
  // @@protoc_insertion_point(field_release:sro.chat.CreateChatChannelMessage.dimension_id)
  return _impl_.dimension_id_.Release();
}
inline void CreateChatChannelMessage::set_allocated_dimension_id(std::string* value) {
  _impl_.dimension_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dimension_id_.IsDefault()) {
          _impl_.dimension_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sro.chat.CreateChatChannelMessage.dimension_id)
}

// -------------------------------------------------------------------

// ChatMessage

// string sender_character_id = 1;
inline void ChatMessage::clear_sender_character_id() {
  _impl_.sender_character_id_.ClearToEmpty();
}
inline const std::string& ChatMessage::sender_character_id() const {
  // @@protoc_insertion_point(field_get:sro.chat.ChatMessage.sender_character_id)
  return _internal_sender_character_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChatMessage::set_sender_character_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_character_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.chat.ChatMessage.sender_character_id)
}
inline std::string* ChatMessage::mutable_sender_character_id() {
  std::string* _s = _internal_mutable_sender_character_id();
  // @@protoc_insertion_point(field_mutable:sro.chat.ChatMessage.sender_character_id)
  return _s;
}
inline const std::string& ChatMessage::_internal_sender_character_id() const {
  return _impl_.sender_character_id_.Get();
}
inline void ChatMessage::_internal_set_sender_character_id(const std::string& value) {
  ;


  _impl_.sender_character_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatMessage::_internal_mutable_sender_character_id() {
  ;
  return _impl_.sender_character_id_.Mutable( GetArenaForAllocation());
}
inline std::string* ChatMessage::release_sender_character_id() {
  // @@protoc_insertion_point(field_release:sro.chat.ChatMessage.sender_character_id)
  return _impl_.sender_character_id_.Release();
}
inline void ChatMessage::set_allocated_sender_character_id(std::string* value) {
  _impl_.sender_character_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_character_id_.IsDefault()) {
          _impl_.sender_character_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sro.chat.ChatMessage.sender_character_id)
}

// string content = 2;
inline void ChatMessage::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& ChatMessage::content() const {
  // @@protoc_insertion_point(field_get:sro.chat.ChatMessage.content)
  return _internal_content();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChatMessage::set_content(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.content_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.chat.ChatMessage.content)
}
inline std::string* ChatMessage::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:sro.chat.ChatMessage.content)
  return _s;
}
inline const std::string& ChatMessage::_internal_content() const {
  return _impl_.content_.Get();
}
inline void ChatMessage::_internal_set_content(const std::string& value) {
  ;


  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatMessage::_internal_mutable_content() {
  ;
  return _impl_.content_.Mutable( GetArenaForAllocation());
}
inline std::string* ChatMessage::release_content() {
  // @@protoc_insertion_point(field_release:sro.chat.ChatMessage.content)
  return _impl_.content_.Release();
}
inline void ChatMessage::set_allocated_content(std::string* value) {
  _impl_.content_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.content_.IsDefault()) {
          _impl_.content_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sro.chat.ChatMessage.content)
}

// int64 sent_time_ms = 3;
inline void ChatMessage::clear_sent_time_ms() {
  _impl_.sent_time_ms_ = ::int64_t{0};
}
inline ::int64_t ChatMessage::sent_time_ms() const {
  // @@protoc_insertion_point(field_get:sro.chat.ChatMessage.sent_time_ms)
  return _internal_sent_time_ms();
}
inline void ChatMessage::set_sent_time_ms(::int64_t value) {
  _internal_set_sent_time_ms(value);
  // @@protoc_insertion_point(field_set:sro.chat.ChatMessage.sent_time_ms)
}
inline ::int64_t ChatMessage::_internal_sent_time_ms() const {
  return _impl_.sent_time_ms_;
}
inline void ChatMessage::_internal_set_sent_time_ms(::int64_t value) {
  ;
  _impl_.sent_time_ms_ = value;
}

// -------------------------------------------------------------------

// SendChatChannelMessageRequest

// string channel_id = 1;
inline void SendChatChannelMessageRequest::clear_channel_id() {
  _impl_.channel_id_.ClearToEmpty();
}
inline const std::string& SendChatChannelMessageRequest::channel_id() const {
  // @@protoc_insertion_point(field_get:sro.chat.SendChatChannelMessageRequest.channel_id)
  return _internal_channel_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SendChatChannelMessageRequest::set_channel_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.channel_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.chat.SendChatChannelMessageRequest.channel_id)
}
inline std::string* SendChatChannelMessageRequest::mutable_channel_id() {
  std::string* _s = _internal_mutable_channel_id();
  // @@protoc_insertion_point(field_mutable:sro.chat.SendChatChannelMessageRequest.channel_id)
  return _s;
}
inline const std::string& SendChatChannelMessageRequest::_internal_channel_id() const {
  return _impl_.channel_id_.Get();
}
inline void SendChatChannelMessageRequest::_internal_set_channel_id(const std::string& value) {
  ;


  _impl_.channel_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SendChatChannelMessageRequest::_internal_mutable_channel_id() {
  ;
  return _impl_.channel_id_.Mutable( GetArenaForAllocation());
}
inline std::string* SendChatChannelMessageRequest::release_channel_id() {
  // @@protoc_insertion_point(field_release:sro.chat.SendChatChannelMessageRequest.channel_id)
  return _impl_.channel_id_.Release();
}
inline void SendChatChannelMessageRequest::set_allocated_channel_id(std::string* value) {
  _impl_.channel_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.channel_id_.IsDefault()) {
          _impl_.channel_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sro.chat.SendChatChannelMessageRequest.channel_id)
}

// .sro.chat.ChatMessage chat_message = 2;
inline bool SendChatChannelMessageRequest::has_chat_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.chat_message_ != nullptr);
  return value;
}
inline void SendChatChannelMessageRequest::clear_chat_message() {
  if (_impl_.chat_message_ != nullptr) _impl_.chat_message_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::sro::chat::ChatMessage& SendChatChannelMessageRequest::_internal_chat_message() const {
  const ::sro::chat::ChatMessage* p = _impl_.chat_message_;
  return p != nullptr ? *p : reinterpret_cast<const ::sro::chat::ChatMessage&>(
      ::sro::chat::_ChatMessage_default_instance_);
}
inline const ::sro::chat::ChatMessage& SendChatChannelMessageRequest::chat_message() const {
  // @@protoc_insertion_point(field_get:sro.chat.SendChatChannelMessageRequest.chat_message)
  return _internal_chat_message();
}
inline void SendChatChannelMessageRequest::unsafe_arena_set_allocated_chat_message(
    ::sro::chat::ChatMessage* chat_message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chat_message_);
  }
  _impl_.chat_message_ = chat_message;
  if (chat_message) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sro.chat.SendChatChannelMessageRequest.chat_message)
}
inline ::sro::chat::ChatMessage* SendChatChannelMessageRequest::release_chat_message() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sro::chat::ChatMessage* temp = _impl_.chat_message_;
  _impl_.chat_message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sro::chat::ChatMessage* SendChatChannelMessageRequest::unsafe_arena_release_chat_message() {
  // @@protoc_insertion_point(field_release:sro.chat.SendChatChannelMessageRequest.chat_message)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sro::chat::ChatMessage* temp = _impl_.chat_message_;
  _impl_.chat_message_ = nullptr;
  return temp;
}
inline ::sro::chat::ChatMessage* SendChatChannelMessageRequest::_internal_mutable_chat_message() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.chat_message_ == nullptr) {
    auto* p = CreateMaybeMessage<::sro::chat::ChatMessage>(GetArenaForAllocation());
    _impl_.chat_message_ = p;
  }
  return _impl_.chat_message_;
}
inline ::sro::chat::ChatMessage* SendChatChannelMessageRequest::mutable_chat_message() {
  ::sro::chat::ChatMessage* _msg = _internal_mutable_chat_message();
  // @@protoc_insertion_point(field_mutable:sro.chat.SendChatChannelMessageRequest.chat_message)
  return _msg;
}
inline void SendChatChannelMessageRequest::set_allocated_chat_message(::sro::chat::ChatMessage* chat_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.chat_message_;
  }
  if (chat_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(chat_message);
    if (message_arena != submessage_arena) {
      chat_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chat_message, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.chat_message_ = chat_message;
  // @@protoc_insertion_point(field_set_allocated:sro.chat.SendChatChannelMessageRequest.chat_message)
}

// -------------------------------------------------------------------

// SendDirectMessageRequest

// string character_id = 1;
inline void SendDirectMessageRequest::clear_character_id() {
  _impl_.character_id_.ClearToEmpty();
}
inline const std::string& SendDirectMessageRequest::character_id() const {
  // @@protoc_insertion_point(field_get:sro.chat.SendDirectMessageRequest.character_id)
  return _internal_character_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SendDirectMessageRequest::set_character_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.character_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.chat.SendDirectMessageRequest.character_id)
}
inline std::string* SendDirectMessageRequest::mutable_character_id() {
  std::string* _s = _internal_mutable_character_id();
  // @@protoc_insertion_point(field_mutable:sro.chat.SendDirectMessageRequest.character_id)
  return _s;
}
inline const std::string& SendDirectMessageRequest::_internal_character_id() const {
  return _impl_.character_id_.Get();
}
inline void SendDirectMessageRequest::_internal_set_character_id(const std::string& value) {
  ;


  _impl_.character_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SendDirectMessageRequest::_internal_mutable_character_id() {
  ;
  return _impl_.character_id_.Mutable( GetArenaForAllocation());
}
inline std::string* SendDirectMessageRequest::release_character_id() {
  // @@protoc_insertion_point(field_release:sro.chat.SendDirectMessageRequest.character_id)
  return _impl_.character_id_.Release();
}
inline void SendDirectMessageRequest::set_allocated_character_id(std::string* value) {
  _impl_.character_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.character_id_.IsDefault()) {
          _impl_.character_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sro.chat.SendDirectMessageRequest.character_id)
}

// .sro.chat.ChatMessage chat_message = 2;
inline bool SendDirectMessageRequest::has_chat_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.chat_message_ != nullptr);
  return value;
}
inline void SendDirectMessageRequest::clear_chat_message() {
  if (_impl_.chat_message_ != nullptr) _impl_.chat_message_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::sro::chat::ChatMessage& SendDirectMessageRequest::_internal_chat_message() const {
  const ::sro::chat::ChatMessage* p = _impl_.chat_message_;
  return p != nullptr ? *p : reinterpret_cast<const ::sro::chat::ChatMessage&>(
      ::sro::chat::_ChatMessage_default_instance_);
}
inline const ::sro::chat::ChatMessage& SendDirectMessageRequest::chat_message() const {
  // @@protoc_insertion_point(field_get:sro.chat.SendDirectMessageRequest.chat_message)
  return _internal_chat_message();
}
inline void SendDirectMessageRequest::unsafe_arena_set_allocated_chat_message(
    ::sro::chat::ChatMessage* chat_message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chat_message_);
  }
  _impl_.chat_message_ = chat_message;
  if (chat_message) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sro.chat.SendDirectMessageRequest.chat_message)
}
inline ::sro::chat::ChatMessage* SendDirectMessageRequest::release_chat_message() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sro::chat::ChatMessage* temp = _impl_.chat_message_;
  _impl_.chat_message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sro::chat::ChatMessage* SendDirectMessageRequest::unsafe_arena_release_chat_message() {
  // @@protoc_insertion_point(field_release:sro.chat.SendDirectMessageRequest.chat_message)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sro::chat::ChatMessage* temp = _impl_.chat_message_;
  _impl_.chat_message_ = nullptr;
  return temp;
}
inline ::sro::chat::ChatMessage* SendDirectMessageRequest::_internal_mutable_chat_message() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.chat_message_ == nullptr) {
    auto* p = CreateMaybeMessage<::sro::chat::ChatMessage>(GetArenaForAllocation());
    _impl_.chat_message_ = p;
  }
  return _impl_.chat_message_;
}
inline ::sro::chat::ChatMessage* SendDirectMessageRequest::mutable_chat_message() {
  ::sro::chat::ChatMessage* _msg = _internal_mutable_chat_message();
  // @@protoc_insertion_point(field_mutable:sro.chat.SendDirectMessageRequest.chat_message)
  return _msg;
}
inline void SendDirectMessageRequest::set_allocated_chat_message(::sro::chat::ChatMessage* chat_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.chat_message_;
  }
  if (chat_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(chat_message);
    if (message_arena != submessage_arena) {
      chat_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chat_message, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.chat_message_ = chat_message;
  // @@protoc_insertion_point(field_set_allocated:sro.chat.SendDirectMessageRequest.chat_message)
}

// -------------------------------------------------------------------

// UpdateChatChannelRequest

// string channel_id = 1;
inline void UpdateChatChannelRequest::clear_channel_id() {
  _impl_.channel_id_.ClearToEmpty();
}
inline const std::string& UpdateChatChannelRequest::channel_id() const {
  // @@protoc_insertion_point(field_get:sro.chat.UpdateChatChannelRequest.channel_id)
  return _internal_channel_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdateChatChannelRequest::set_channel_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.channel_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.chat.UpdateChatChannelRequest.channel_id)
}
inline std::string* UpdateChatChannelRequest::mutable_channel_id() {
  std::string* _s = _internal_mutable_channel_id();
  // @@protoc_insertion_point(field_mutable:sro.chat.UpdateChatChannelRequest.channel_id)
  return _s;
}
inline const std::string& UpdateChatChannelRequest::_internal_channel_id() const {
  return _impl_.channel_id_.Get();
}
inline void UpdateChatChannelRequest::_internal_set_channel_id(const std::string& value) {
  ;


  _impl_.channel_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateChatChannelRequest::_internal_mutable_channel_id() {
  ;
  return _impl_.channel_id_.Mutable( GetArenaForAllocation());
}
inline std::string* UpdateChatChannelRequest::release_channel_id() {
  // @@protoc_insertion_point(field_release:sro.chat.UpdateChatChannelRequest.channel_id)
  return _impl_.channel_id_.Release();
}
inline void UpdateChatChannelRequest::set_allocated_channel_id(std::string* value) {
  _impl_.channel_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.channel_id_.IsDefault()) {
          _impl_.channel_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sro.chat.UpdateChatChannelRequest.channel_id)
}

// string name = 2;
inline bool UpdateChatChannelRequest::has_name() const {
  return optional_name_case() == kName;
}
inline void UpdateChatChannelRequest::set_has_name() {
  _impl_._oneof_case_[0] = kName;
}
inline void UpdateChatChannelRequest::clear_name() {
  if (optional_name_case() == kName) {
    _impl_.optional_name_.name_.Destroy();
    clear_has_optional_name();
  }
}
inline const std::string& UpdateChatChannelRequest::name() const {
  // @@protoc_insertion_point(field_get:sro.chat.UpdateChatChannelRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdateChatChannelRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  if (optional_name_case() != kName) {
    clear_optional_name();

    set_has_name();
    _impl_.optional_name_.name_.InitDefault();
  }
  _impl_.optional_name_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.chat.UpdateChatChannelRequest.name)
}
inline std::string* UpdateChatChannelRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:sro.chat.UpdateChatChannelRequest.name)
  return _s;
}
inline const std::string& UpdateChatChannelRequest::_internal_name() const {
  if (optional_name_case() != kName) {
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.optional_name_.name_.Get();
}
inline void UpdateChatChannelRequest::_internal_set_name(const std::string& value) {
  if (optional_name_case() != kName) {
    clear_optional_name();

    set_has_name();
    _impl_.optional_name_.name_.InitDefault();
  }


  _impl_.optional_name_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateChatChannelRequest::_internal_mutable_name() {
  if (optional_name_case() != kName) {
    clear_optional_name();

    set_has_name();
    _impl_.optional_name_.name_.InitDefault();
  }
  return _impl_.optional_name_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* UpdateChatChannelRequest::release_name() {
  // @@protoc_insertion_point(field_release:sro.chat.UpdateChatChannelRequest.name)
  if (optional_name_case() != kName) {
    return nullptr;
  }
  clear_has_optional_name();
  return _impl_.optional_name_.name_.Release();
}
inline void UpdateChatChannelRequest::set_allocated_name(std::string* value) {
  if (has_optional_name()) {
    clear_optional_name();
  }
  if (value != nullptr) {
    set_has_name();
    _impl_.optional_name_.name_.InitAllocated(value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:sro.chat.UpdateChatChannelRequest.name)
}

// string dimension = 3;
inline bool UpdateChatChannelRequest::has_dimension() const {
  return optional_dimension_case() == kDimension;
}
inline void UpdateChatChannelRequest::set_has_dimension() {
  _impl_._oneof_case_[1] = kDimension;
}
inline void UpdateChatChannelRequest::clear_dimension() {
  if (optional_dimension_case() == kDimension) {
    _impl_.optional_dimension_.dimension_.Destroy();
    clear_has_optional_dimension();
  }
}
inline const std::string& UpdateChatChannelRequest::dimension() const {
  // @@protoc_insertion_point(field_get:sro.chat.UpdateChatChannelRequest.dimension)
  return _internal_dimension();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdateChatChannelRequest::set_dimension(Arg_&& arg,
                                                     Args_... args) {
  if (optional_dimension_case() != kDimension) {
    clear_optional_dimension();

    set_has_dimension();
    _impl_.optional_dimension_.dimension_.InitDefault();
  }
  _impl_.optional_dimension_.dimension_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.chat.UpdateChatChannelRequest.dimension)
}
inline std::string* UpdateChatChannelRequest::mutable_dimension() {
  std::string* _s = _internal_mutable_dimension();
  // @@protoc_insertion_point(field_mutable:sro.chat.UpdateChatChannelRequest.dimension)
  return _s;
}
inline const std::string& UpdateChatChannelRequest::_internal_dimension() const {
  if (optional_dimension_case() != kDimension) {
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.optional_dimension_.dimension_.Get();
}
inline void UpdateChatChannelRequest::_internal_set_dimension(const std::string& value) {
  if (optional_dimension_case() != kDimension) {
    clear_optional_dimension();

    set_has_dimension();
    _impl_.optional_dimension_.dimension_.InitDefault();
  }


  _impl_.optional_dimension_.dimension_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateChatChannelRequest::_internal_mutable_dimension() {
  if (optional_dimension_case() != kDimension) {
    clear_optional_dimension();

    set_has_dimension();
    _impl_.optional_dimension_.dimension_.InitDefault();
  }
  return _impl_.optional_dimension_.dimension_.Mutable( GetArenaForAllocation());
}
inline std::string* UpdateChatChannelRequest::release_dimension() {
  // @@protoc_insertion_point(field_release:sro.chat.UpdateChatChannelRequest.dimension)
  if (optional_dimension_case() != kDimension) {
    return nullptr;
  }
  clear_has_optional_dimension();
  return _impl_.optional_dimension_.dimension_.Release();
}
inline void UpdateChatChannelRequest::set_allocated_dimension(std::string* value) {
  if (has_optional_dimension()) {
    clear_optional_dimension();
  }
  if (value != nullptr) {
    set_has_dimension();
    _impl_.optional_dimension_.dimension_.InitAllocated(value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:sro.chat.UpdateChatChannelRequest.dimension)
}

// bool public = 4;
inline bool UpdateChatChannelRequest::has_public_() const {
  return optional_public_case() == kPublic;
}
inline void UpdateChatChannelRequest::set_has_public_() {
  _impl_._oneof_case_[2] = kPublic;
}
inline void UpdateChatChannelRequest::clear_public_() {
  if (optional_public_case() == kPublic) {
    _impl_.optional_public_.public__ = false;
    clear_has_optional_public();
  }
}
inline bool UpdateChatChannelRequest::public_() const {
  // @@protoc_insertion_point(field_get:sro.chat.UpdateChatChannelRequest.public)
  return _internal_public_();
}
inline void UpdateChatChannelRequest::set_public_(bool value) {
  _internal_set_public_(value);
  // @@protoc_insertion_point(field_set:sro.chat.UpdateChatChannelRequest.public)
}
inline bool UpdateChatChannelRequest::_internal_public_() const {
  if (optional_public_case() == kPublic) {
    return _impl_.optional_public_.public__;
  }
  return false;
}
inline void UpdateChatChannelRequest::_internal_set_public_(bool value) {
  if (optional_public_case() != kPublic) {
    clear_optional_public();
    set_has_public_();
  }
  _impl_.optional_public_.public__ = value;
}

inline bool UpdateChatChannelRequest::has_optional_name() const {
  return optional_name_case() != OPTIONAL_NAME_NOT_SET;
}
inline void UpdateChatChannelRequest::clear_has_optional_name() {
  _impl_._oneof_case_[0] = OPTIONAL_NAME_NOT_SET;
}
inline bool UpdateChatChannelRequest::has_optional_dimension() const {
  return optional_dimension_case() != OPTIONAL_DIMENSION_NOT_SET;
}
inline void UpdateChatChannelRequest::clear_has_optional_dimension() {
  _impl_._oneof_case_[1] = OPTIONAL_DIMENSION_NOT_SET;
}
inline bool UpdateChatChannelRequest::has_optional_public() const {
  return optional_public_case() != OPTIONAL_PUBLIC_NOT_SET;
}
inline void UpdateChatChannelRequest::clear_has_optional_public() {
  _impl_._oneof_case_[2] = OPTIONAL_PUBLIC_NOT_SET;
}
inline UpdateChatChannelRequest::OptionalNameCase UpdateChatChannelRequest::optional_name_case() const {
  return UpdateChatChannelRequest::OptionalNameCase(_impl_._oneof_case_[0]);
}
inline UpdateChatChannelRequest::OptionalDimensionCase UpdateChatChannelRequest::optional_dimension_case() const {
  return UpdateChatChannelRequest::OptionalDimensionCase(_impl_._oneof_case_[1]);
}
inline UpdateChatChannelRequest::OptionalPublicCase UpdateChatChannelRequest::optional_public_case() const {
  return UpdateChatChannelRequest::OptionalPublicCase(_impl_._oneof_case_[2]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace chat
}  // namespace sro


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_sro_2fchat_2fchat_2eproto_2epb_2eh
