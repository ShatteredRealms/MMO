//Generated by TurboLink CodeGenerator, do not edit!
#include "MapContext.h"
#include "SSroGameserver/MapClient.h"
#include "MapService_Private.h"
#include "MapMarshaling.h"
#include "SGoogleApi/AnnotationsMarshaling.h"
#include "SGoogleProtobuf/EmptyMarshaling.h"
#include "SSro/GlobalsMarshaling.h"
#include "TurboLinkGrpcManager.h"

GrpcContext_MapService_GetMap::GrpcContext_MapService_GetMap(FGrpcContextHandle _Handle, UGrpcService* _Service, UGrpcClient* _Client)
	: Super(_Handle, _Service, _Client)
{
}

void GrpcContext_MapService_GetMap::Call(const FGrpcSroTargetId& Request)
{
	check(GetState() == EGrpcContextState::Ready);
	UpdateState(EGrpcContextState::Initialing);

	::sro::TargetId rpcRequest;
	TURBOLINK_TO_GRPC(&Request, &rpcRequest);

	UMapService* service = (UMapService*)Service;
	RpcReaderWriter = service->d->Stub->AsyncGetMap(RpcContext.get(), rpcRequest, service->TurboLinkManager->d->CompletionQueue.get());
	RpcReaderWriter->ReadInitialMetadata(InitialTag);
}

void GrpcContext_MapService_GetMap::OnRpcEvent(bool Ok, const void* EventTag)
{
	Super::OnRpcEventInternal(Ok, EventTag, 
		[this](const FGrpcResult& _Result, ::sro::gameserver::Map* _RpcResponse) 
		{
			UMapServiceClient* client = (UMapServiceClient*)(this->Client);
			if (!(client->OnGetMapResponse.IsBound())) return;

			FGrpcSroGameserverMap response;
			if (_RpcResponse) {
				GRPC_TO_TURBOLINK(_RpcResponse, &response);
			}
			client->OnGetMapResponse.Broadcast(Handle, _Result, response);
		}
	);
}

GrpcContext_MapService_GetMaps::GrpcContext_MapService_GetMaps(FGrpcContextHandle _Handle, UGrpcService* _Service, UGrpcClient* _Client)
	: Super(_Handle, _Service, _Client)
{
}

void GrpcContext_MapService_GetMaps::Call(const FGrpcGoogleProtobufEmpty& Request)
{
	check(GetState() == EGrpcContextState::Ready);
	UpdateState(EGrpcContextState::Initialing);

	::google::protobuf::Empty rpcRequest;
	TURBOLINK_TO_GRPC(&Request, &rpcRequest);

	UMapService* service = (UMapService*)Service;
	RpcReaderWriter = service->d->Stub->AsyncGetMaps(RpcContext.get(), rpcRequest, service->TurboLinkManager->d->CompletionQueue.get());
	RpcReaderWriter->ReadInitialMetadata(InitialTag);
}

void GrpcContext_MapService_GetMaps::OnRpcEvent(bool Ok, const void* EventTag)
{
	Super::OnRpcEventInternal(Ok, EventTag, 
		[this](const FGrpcResult& _Result, ::sro::gameserver::Maps* _RpcResponse) 
		{
			UMapServiceClient* client = (UMapServiceClient*)(this->Client);
			if (!(client->OnGetMapsResponse.IsBound())) return;

			FGrpcSroGameserverMaps response;
			if (_RpcResponse) {
				GRPC_TO_TURBOLINK(_RpcResponse, &response);
			}
			client->OnGetMapsResponse.Broadcast(Handle, _Result, response);
		}
	);
}

GrpcContext_MapService_CreateMap::GrpcContext_MapService_CreateMap(FGrpcContextHandle _Handle, UGrpcService* _Service, UGrpcClient* _Client)
	: Super(_Handle, _Service, _Client)
{
}

void GrpcContext_MapService_CreateMap::Call(const FGrpcSroGameserverCreateMapRequest& Request)
{
	check(GetState() == EGrpcContextState::Ready);
	UpdateState(EGrpcContextState::Initialing);

	::sro::gameserver::CreateMapRequest rpcRequest;
	TURBOLINK_TO_GRPC(&Request, &rpcRequest);

	UMapService* service = (UMapService*)Service;
	RpcReaderWriter = service->d->Stub->AsyncCreateMap(RpcContext.get(), rpcRequest, service->TurboLinkManager->d->CompletionQueue.get());
	RpcReaderWriter->ReadInitialMetadata(InitialTag);
}

void GrpcContext_MapService_CreateMap::OnRpcEvent(bool Ok, const void* EventTag)
{
	Super::OnRpcEventInternal(Ok, EventTag, 
		[this](const FGrpcResult& _Result, ::sro::gameserver::Map* _RpcResponse) 
		{
			UMapServiceClient* client = (UMapServiceClient*)(this->Client);
			if (!(client->OnCreateMapResponse.IsBound())) return;

			FGrpcSroGameserverMap response;
			if (_RpcResponse) {
				GRPC_TO_TURBOLINK(_RpcResponse, &response);
			}
			client->OnCreateMapResponse.Broadcast(Handle, _Result, response);
		}
	);
}

GrpcContext_MapService_EditMap::GrpcContext_MapService_EditMap(FGrpcContextHandle _Handle, UGrpcService* _Service, UGrpcClient* _Client)
	: Super(_Handle, _Service, _Client)
{
}

void GrpcContext_MapService_EditMap::Call(const FGrpcSroGameserverEditMapRequest& Request)
{
	check(GetState() == EGrpcContextState::Ready);
	UpdateState(EGrpcContextState::Initialing);

	::sro::gameserver::EditMapRequest rpcRequest;
	TURBOLINK_TO_GRPC(&Request, &rpcRequest);

	UMapService* service = (UMapService*)Service;
	RpcReaderWriter = service->d->Stub->AsyncEditMap(RpcContext.get(), rpcRequest, service->TurboLinkManager->d->CompletionQueue.get());
	RpcReaderWriter->ReadInitialMetadata(InitialTag);
}

void GrpcContext_MapService_EditMap::OnRpcEvent(bool Ok, const void* EventTag)
{
	Super::OnRpcEventInternal(Ok, EventTag, 
		[this](const FGrpcResult& _Result, ::sro::gameserver::Map* _RpcResponse) 
		{
			UMapServiceClient* client = (UMapServiceClient*)(this->Client);
			if (!(client->OnEditMapResponse.IsBound())) return;

			FGrpcSroGameserverMap response;
			if (_RpcResponse) {
				GRPC_TO_TURBOLINK(_RpcResponse, &response);
			}
			client->OnEditMapResponse.Broadcast(Handle, _Result, response);
		}
	);
}

GrpcContext_MapService_DeleteMap::GrpcContext_MapService_DeleteMap(FGrpcContextHandle _Handle, UGrpcService* _Service, UGrpcClient* _Client)
	: Super(_Handle, _Service, _Client)
{
}

void GrpcContext_MapService_DeleteMap::Call(const FGrpcSroTargetId& Request)
{
	check(GetState() == EGrpcContextState::Ready);
	UpdateState(EGrpcContextState::Initialing);

	::sro::TargetId rpcRequest;
	TURBOLINK_TO_GRPC(&Request, &rpcRequest);

	UMapService* service = (UMapService*)Service;
	RpcReaderWriter = service->d->Stub->AsyncDeleteMap(RpcContext.get(), rpcRequest, service->TurboLinkManager->d->CompletionQueue.get());
	RpcReaderWriter->ReadInitialMetadata(InitialTag);
}

void GrpcContext_MapService_DeleteMap::OnRpcEvent(bool Ok, const void* EventTag)
{
	Super::OnRpcEventInternal(Ok, EventTag, 
		[this](const FGrpcResult& _Result, ::google::protobuf::Empty* _RpcResponse) 
		{
			UMapServiceClient* client = (UMapServiceClient*)(this->Client);
			if (!(client->OnDeleteMapResponse.IsBound())) return;

			FGrpcGoogleProtobufEmpty response;
			if (_RpcResponse) {
				GRPC_TO_TURBOLINK(_RpcResponse, &response);
			}
			client->OnDeleteMapResponse.Broadcast(Handle, _Result, response);
		}
	);
}
